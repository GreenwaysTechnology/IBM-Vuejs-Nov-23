				VUE JS - VUE 3
.....................................................................................

Pre Knowldege:
1.HTML 5
2.CSS 3
3.Javascript ES 5 and ES6 (Basic Features)
4.Node js fundamentals - how to use npm, package.json

Nice to have:
1.Angular
2.React

Vue => Features of Angular and Features of React
..................................................................................
What is vue.js?
 Vue is a javascript framework for building user interfaces.

What is User interface?
  The application where user interacts.

Types of user interface application:

1.Desktop applications
2.Web applications which is running browser.
3.Mobile applications
   Native,Browser based,Hybrid
4.Any other device based applications.

Types of web application:

Server side Web Application:
.............................

1.Static web apps - 1989 to 1995
https://home.cern/science/computing/where-web-was-born

2.Dynamic Content Generation Web App - 1996 to till date
  -CGI - C,Perl
  -J2EE - Java, Servlet
  -ASP - VbScript, vb
  -PHP - PHP
  -.net,nodejs,ruby..rails....
Output: HTML pages generated on fly.

3.Biz to Biz integration:
   Incase two biz organization want to share their information via internet
 DCG technology was not enough.
 Web Services:  1998 to till Date
  COMMON DATA Interchange format
   instead of exchanging html pages we can exchange data in the form of XML
  -XML - Soap Web Services
 2005 on wards - REST Full web services

,.............................................................................
Client side Web Apps:

Browser based :
 Desktop browsers
 Mobile browsers

 Powered with HTML With Javascript 
    Incase of dynamic web apps, html genereated by server and javascript changed and
 processed html pages at client side.


In 2007,W3c Introduced new web development arch, called "Single Page Web Application/SPA"

In SPA

 Client user interface applications were written using "HTML 5,CSS3,Javascript" where as server side applications are "Web Services-REST API" which serves data to the client.



SPA:
       Client User App (HTML,CSS,JS)<-------------------> REST API

SPA Frameworks:
1.Mustache.js
2.Angular.js
3.React
4.Angular
5.Vue.js
.....................................................................................
				Client side web technology
.....................................................................................

There are three primary languages

1.HTML 5
2.Javascript
3.CSS

DOM Programming:
................

What is DOM?

  if you want to understand DOM, you need to understand.

What is HTML? How it works?

HTML is the programming language, DSL/Declarative programming lanugage. Domain specific language is nothing but the language built for specific domain,which cant be used for other purposes.

Since HTML is programming language,do you think that the code written using html is compiled?

c:
 hello.c--->compile--->hello.obj(compiled code)--->run compiled code by runtime...

HTML:
Html code itself is compiled and executed- every thing happens within browser-in memory compilation.

index.html---->parsing--->parsed code---->compilation---->binary code-->run compiled code by runtime-->Final output on the screen.


index.html -  source code

<html>
 <head>
   <title>HTML</title>
 </head>
 <body>
     <h1>Welcome</h1>
 </body>
</html>
 |
 load into browser
 |
 loader- program which loads html into browser
  |
 uses http or ftp protocal.
  |
 Parser - parser is special compiler which converts source code into lexical tree	  (string tree)
 |
 html
  head
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
  |
 compiler-compilation- convert source code into assembly language
 |
html ---XX3434X
  head
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
...................................................................
Runtime:
.......
 During runtime, compiled code is loaded into main memory.
 What ever you load into main memory, there is structure.

Runtime will create LinkedList(c) for the entire html document

html - Node
  head- Node
   title -Node
      HTML
   title
 head
 body -Node
     h1  - Node
      Welcome
     h1
 body
html

Nodes are connected each other in Hierchical Structure(Tree)

Linking the Nodes (Tree)

body -Node
    |
     h1  - Node
      |
        Welcome
     h1
 body
 |
Layout Engine/Paint Engine
   |
  will convert into pxs - Final Ouput

            At End , the html page is "Tree Data Structure"
..........................***.....................................................
			The Netscap Communication and HTML Tree
.................................................................................
Netscap started a project,to access rendered "tree" via program, in order to process the rendered tree.

Netcap initally decided to introduce c program,later who decided to change their mind to "Java".

Java was not also not suitable , the reason was , java was the big language , putting the language inside browser is not suitable.

Nets cap finally decided who did not want eiter c or java, but java like language
 - "The Birth of Javascript" 

The Javascript was introduced  as light weight programming language to access the tree,process the tree.

How to reprsent html inside javascript engine?
 
 Netscap took an idea "Object" Model.

Every html element is object, which is created once the browser loads the html into browser,and also object can be created using apis..

Javascript engins forms the tree called "Object Tree"

.....................................................................................
			Netscap Objects and W3c
.....................................................................................

After Object tree model and javascript success, W3C  decided to standarize this arch/technology.

After standarization, w3c published a spec called "DOM" -  Document Object Model


How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT Inside javascript engine is "Object"

HTML Elements(p,h1,div,img) are  represented inside browser as "Node", inside Javascript Engine "Object - DOM "


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine->Paint Engine-->Will repaint changes-->User will see the final result.
.....................................................................................
				DOM Programming
.....................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js

           "Vue or React or Angular are just DOM abstractions"
....................................................................................
         		Vue JS and its application type
....................................................................................

vue js is a framework used to build "different types of client side apps"

1.standalone script application.
   Enchancing html(generated by server) by adding js / js lib (jquery)

if you have traditional web apps written using server side technology like j2ee,asp.net,php which has embeded "js/jquery" lib..

    "Vue is Declarative replacement of imperative "Jquery"



2.Web Component application
  Vue supports to create web component arch based applications

3.Single Page Web Application(SPA)
    Vue is primarily popular for building SPA web applications.

4.Full stack/SSR - Server Rendered Apps
    Partial SSR - SPA + Server rendering
    Full SSR 
    SSG - Static Site Generation
    ISR  - Incremental Static Rendering

Pure SPA's has limitations when the app is sensitive to SEO and time to constent.
 Every thing happens in the browser side with respective SPA.

 Vue apps can be compiled/render in the server side.
 Server will generate html pages before sending to the browser(client) - Pre  rendering.
 https://nuxtjs.org/ -  for ssr with vuejs


5.SSG/JAMStack
   Server side static file generation(96), instead of build dynamic apps, suppose we need static apps.

  Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files.

 This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. 

Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.
				
https://jamstack.org/

vue supported frameworks - VitePress,Nuxt

Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!
....................................................................................

App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices
   Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data and also dynamic data...
.....................................................................................
				Vue App Development
....................................................................................

Development work flows:

1.Without Build Tool
   Build tools like webpack,rollup,vitePress....
2.With Build Tool


Project Setup:

1.without build tool
2.with build tool.


1.Without build tool:
   We can create "Standalone script apps"

steps:


>mkdir vue-legacy

vue-legacy>mkdir src

vue-legacy>code .

create index.html outside src dir

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue app</title>
</head>

<body>
    <h1>Vue Application</h1>

</body>

</html>

in order to run the above html , we need some web server, 

install live server in the vs code as Extension..

open index.html using live server.

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build

Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
     <script src="https://unpkg.com/vue@3.3.9/dist/vue.global.prod.js"></script>

eg:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue app</title>
    <!-- Dev build -->
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <!-- Production Build -->
    <script src="https://unpkg.com/vue@3.3.9/dist/vue.global.prod.js"></script>

</head>

<body>
    <h1>Vue Application</h1>

</body>

</html>
.....................................................................................

Core concepts of Vue
....................
			   Vue Application

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.

Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

Eg: Imperative way of creating dom elements using plain js.
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue app</title>
    <!-- Dev build -->
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <!-- Production Build -->
    <script src="https://unpkg.com/vue@3.3.9/dist/vue.global.prod.js"></script>

</head>

<body>
    <h1>Vue Application</h1>
    <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('....init....')
            const Heading = document.createElement('h1')
            //set properties
            Heading.innerHTML = 'Hello,DOM'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement()
    </script>
</body>

</html>
.....................................................................................

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates
Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
	java script => binds the state(data)/ biz logic

HTML + Extra Syntax + Bizlogic+data = Vue.js

How vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue organizes the UI into smaller and smaller UI
=>VUE breaks the complex UI into Smallar UI
    This model is called called as "Compostion"


Why Compostion?
=>The UI can be reused any where in the app and also outside app.
=>The code maintaince is very easy,because it is independant.

	    "The arch is called as Component Driven Arch"


Component means parts of something.

.....................................................................................
			 Vue Instance /Application Object
.....................................................................................

In vuejs, the whole application(User interface), is composed into the object called
"Vue instance".

Vue Versions:

Vue 2.x
Vue 3.x

Vue Instance Creation:
......................
Vue 2
......

var app = new Vue({})

Vue 3:

We can get Vue instance:

 1.Via Global Vue Variable
 2.Via ES  6 Modules
...................................................................................
			A.Vue Instance via Vue Global Variables
...................................................................................
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue app</title>
    <!-- Dev build -->
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <!-- Production Build -->
    <script src="https://unpkg.com/vue@3.3.9/dist/vue.global.prod.js"></script>

</head>

<body>
    <h1>Vue Application</h1>
    <div id="root">
    </div>
    <!-- Create vue instance via Vue Global Variable -->
    <script>
        const vueInstance = Vue
        console.log(vueInstance)
        console.log(vueInstance.version)
    </script>
</body>

</html>
.....................................................................................
			B.Getting Vue instance via ES  Modules
.....................................................................................

ES 6 Module Keywords
 export
 export default
 import

Can we use ES6 module keywords inside browser directly?

  Not Possible , es 6 keywords wont work directly, but modern browsers support es 6 module  are supported via some configuration.

Eg: How to use es 6 modules inside browser.

src/name.js
export const name='Subramnaian'

src/index.js
import { name } from "./name";
console.log(name)

No, in older browsers
yes in modern browsers

Generally browser has no facility to link files and share code using "ES 6 modules keyword "

"Uncaught SyntaxError: Cannot use import statement outside a module (at index.js:1:1)

How to run es 6 module based apps inside browsers

Solution:

1.Using build tools - webpack,rollup.
   React,angular uses this tool behind it.

2.Using browser alone
   using type=module

 Recently browsers vendors added a capability to link files at browser level, this is still in experimental mode- many browsers(old browsers may not support)	
...................................................................................
			 ES 6 Modules and Browsers

src/name.js
export const name='Subramanian'
src/index.js
import {name} from './name.js'

console.log(name)

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script src="src/index.js" type="module"></script>
</head>
<body>
    <h1>ES 6 Modules</h1>    
</body>
</html>

Note:
 when you import you have to use "fileName.js"  
eg : import {name} './name.js" 
 in script tag add type="module" attribute

.....................................................................................
			Can we use import statement inside html

can i import "src/name.js or src/index.js" inside script section of html.

2.Using browser alone
   Dynamically Import JavaScript with Import Maps

if you want import any js code within html file.
<script type="importmap">
  // JSON object defining import
</script>

eg:
<script type="importmap">
  {
    "imports": {
      "square": "./module/shapes/square.js",
      "circle": "https://example.com/shapes/circle.js"
    }
  }
</script>

eg;
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES 6 Module app</title>
    <script type="importmap">
        {
            "imports": {
                "name": "./src/name.js"
            }
        }
    </script>
</head>

<body>
    <h1>ES 6 Module Application</h1>
    <script type="module">
        import { name } from 'name'
        console.log(name)
    </script>
</body>

</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If you are using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>


How to use vue using importMap syntax:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Es 6 modules</title>
    <!-- Polyfil for import map -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "name":"./src/name.js",
            "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>
</head>

<body>
    <h1>Using ES 6 Modules within HTML</h1>
    <script type="module">
        import { name } from 'name'
        import { createApp } from 'vue'

        //calling createApp function,which returns "Vue Instance"
        const app = createApp()
        console.log(app)
        console.log(`version`,app.version)
        console.log('name', name)
    </script>
</body>

</html>
.....................................................................................
	Vue is Root Instance having lot of methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 
etc...


Vue is component based framework, createApp method takes root/Entry component

function createApp(rootComponent: Component, rootProps?: object): App

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES 6 Module app</title>
    <!-- Poly fill lib for import map -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
</head>

<body>
    <div id="root">

    </div>
    <script type="module">
        //step 1: import factory method called createApp from the root vue instance
        import { createApp } from 'vue'
        //step 2: create application instance and pass root component
        const AppComponent = {
            template: `
                <h1>Welcome to Vue Application</h1>
            `
        }
        const app = createApp(AppComponent)

        //Mount root component into root element
        console.log(app)
        //pass selector as parameter to the mount method
        app.mount('#root')

    </script>
</body>

</html>
.....................................................................................
		   User interface development Guidelines
.....................................................................................

1.User interface must be broken into smallar and smaller -Composition- Component Model.

2.User interface is organized in tree structure
    That is basic html design model, we need to follow the same.

 <div>
     <div></div>
     <div></div>
     <div></div>
     <div></div>
 </div>
3.In tree model, there must be one root Element.
.....................................................................................
			 Root Component- root Element
....................................................................................

Component creations:

1.React

  function Logo(){
	return <img src="logo.png"/>
  }
2.In Angular
 
  @Component({selector:'app-logo',template:'<img src="logo.png"/>'})
  export class Logo {}

3.In Vue
 Component is Object which is represented as literal object.

const Logo= { 

}
What a Component can hold?

component's meta data

const Logo= { 
  template:'',
  render:'''
  compilerOptions:{},
  data:function(){}
}

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends

Misc
name
inheritAttrs
components
directives

Component Instance api and variables
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()


const Logo ={
  ui: {},
  state:{}
  others:{}
  methods:{} 
}
.....................................................................................
			 Vue Application setup using Build tools
.....................................................................................

Build tools are js based tools for create ,manage js app work flows.
Build tools are based npm.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.


We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates


Create vue js (vue 3) project based on vite.

>npm init vue@latest
Need to install the following packages:
create-vue@3.8.0
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\IBM\2023\Nov\VueJs\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev

cd vue-app
code .
.....................................................................................

Folders and File Structure:
..........................

package.json

{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test:unit": "vitest"
  },
  "dependencies": {
    "vue": "^3.3.4"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.4.0",
    "@vue/test-utils": "^2.4.1",
    "jsdom": "^22.1.0",
    "vite": "^4.4.11",
    "vitest": "^0.34.6"
  }
}

vite.config.js
 It is build tool for vue application.

import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
....................................................................................
src
 |
 main.js 
   It is entry file for vue applications
|
components
  It is going to hold other components

src/assets
  |
  logos,pictures,css files

How to test the application?

npm run dev
.....................................................................................
		             VUE Coding Style
.....................................................................................
Vue coding can be classified into two category.

Vue 2.x and Vue 3.x

Note: Inside vue 3, we can use Vue 2 style coding...

Vue coding can be classified based on API Style:

1.Options API Based Style 
   -Vue 2.x and Vue 3.x
   -It is old way of writing coding
2.Composition API Based Style
   -Vue 3.X based 
.....................................................................................
			Component creational Patterns
.....................................................................................

There are two patterns available to create components.

1.Plain Javascript pattern
2.Single File Components- SFC Pattern

1.Plain Javascript Pattern.
 
  As the name suggest, Plain javascript pattern, encapsulate the component inside literal object.

Without build tool: Standalone script application:

const App = { 
  template:`<h1>Hello</h1>`
}

With build tool: SPA

App.js

export default {
  //options
  ..options
}

It is more on imperative way of writing coding: It is not recommended
......

2.Single File Components- SFC Pattern
 
 As name suggests, All component logic would be inside single file.
 It is more declarative way of writing code, It is highly recommended

....................................................................................

     "Plain Javascript Pattern is used inside Standalone Script application"-Without                                   build tool

     "SFC pattern is used inside  build work flow"

Eg:
Plain javascript pattern:

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES 6 Module app</title>
    <!-- Poly fill lib for import map -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
                "app" : "./src/App.js"
            }
        }
    </script>
</head>

<body>
    <div id="root">

    </div>
    <script type="module">
        //step 1: import factory method called createApp from the root vue instance
        import { createApp } from 'vue'
        import AppComponent from 'app'
        const app = createApp(AppComponent)
        //pass selector as parameter to the mount method
        app.mount('#root')

    </script>
</body>

</html>

src/App.js

export default {
    template: `
        <div>
            <h1>Hello Vue </h1>
        </div>
    `
}
................................................................................
	Plain javascript is usefull where there is no build workflow
	SFC is usefull and necessary in build work flow
	
	Plain javascript pattern files are saved with ".js" extension
	SFC pattern files are saved with ".vue" extension
.....................................................................................
				SFC pattern
.....................................................................................
In SFC pattern file, contains three segments

1.template
   Collection of html elements and vue instructions
2.javascript
   Collection of variables and methods- biz logic
3.style
  CSS style for a component

IN SFC pattern we isloate very clearly into three sections.

SFC files are saved with ".vue" extension.	

<script>
   //all javascript code goes
</script>

<template>
   // template code
</template>

<style>
  //style code
</style>

eg:
SFC pattern:

src/App.vue

<!-- Three segments -->
<script></script>
<template>
    <div>
        <h1>Welcome to Vue</h1>
    </div>
</template>
<style></style>

src/main.js
// import './assets/main.css'
import { createApp } from 'vue'

import App from './App.vue'

createApp(App).mount('#app')

.....................................................................................
		"Going Foward we focus only SFC pattern"
.....................................................................................
Inside SFC, We can use either Options API based style or Composition Api based style.

			Commonality between both patterns
	     	        (Options api and Composition api)

1.Code segementation is same for both patterns

 <script></script>
 <template></template>
 <style></style>
.....................................................................................

Options API pattern:
....................

In Options API pattern, we return Options object, which contains necessary configuration.

<script>
 //return options object
 export default {
    //options
 }
</script>

Sample:
<script>
export default {
    props: ['something'],
    data() {
        return {
            name: 'Subramaian'
        }
    }
}
</script>
<template>
    <h1>Components Using Options API Pattern</h1>
</template>
<style></style>

 }
</script>

.....................................................................................
				Composition API Pattern
.....................................................................................

=>It is vue 3.x style of writing code.
=>In this pattern, we define a component logic's using imported api functions
=>In this pattern, we can write js directly within script tag.
=>In composition pattern we have two style of coding.


			Composition API Pattern
				|
	-------------------------------------------------------
	|                                                    |
    with setup function                                    with setup attribute



with setup function:

1.It looks like Options api pattern but code refactoring has been done.
2.It looks like imperative style of compostion api.

<script>
// compostion api pattern;using setup function
export default {
    setup() {
        //all js initalization code will go
    }
}
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

with setup attribute:
.....................
=>It is same as setup function only but it is more declarative.
=>It has been built on the top of setup function...
=>We dont need to write extra code, vue compiler will write for us.

<!-- Compostion api using setup attribute -->
<script setup>
// all javascript code is written directly into script tag. looks like normal js code
const name = 'Subramanian'
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

				     Vue App
		   			|
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                       |
	      	with setup function                           with setup attribute

	
Component with Options api:
...........................
<!-- Options api pattern -->
<script>
// Options Object : we have to return always options Object
export default {
   //js logic goes
}
</script>
<template>
 <h1>Options Api Demo</h1>
</template>
<style>

</style>

Component with compostion api : with setup function
<script>
export default {
    setup() {

    }
}
</script>
<template>
    <h1>Composition api with setup function</h1>
</template>
<style>

</style>

Composition with setup attribute:
<script setup>

</script>
<template>
    <h1>Composition api with setup Attribute</h1>
</template>
<style>

</style>
.....................................................................................
			    Component Composition
.....................................................................................
Organization of comonents in hierachical order.

<div id="root">
   <App>
	<Hello></Hello>
   </App>
</div>

Component Compostion with "Options Api":
.........................................

src/components/Hello.vue
<script>
</script>
<template>
    <h1>Hello Component</h1>
</template>
<style></style>

src/App.vue
<script>
import Hello from './components/Hello.vue';

</script>
<template>
    <h1>Application</h1>
    <Hello />
</template>
<style></style>

After running,you will not able to see the Hello component output.

Every component is object, must have been created.
Who will create component?
 Vue runtime need to create Component..

In the above example the component has not been created, thats why did not see output.

How to tell vue to create component?

Via Configuration,It is similar to angular DI configuration.

In options api, we need to configure via "components" key.

eg:
src/App.vue

<script>
import Hello from './components/Hello.vue';

// options api 
export default {
    // Registring components/ tell to vue engine to create component
    components: {
        //Hello: Hello
        Hello
    }
}

</script>
<template>
    <h1>Application</h1>
    <Hello />
</template>
<style></style>


More Components:
................
src/components/Hai.vue
<script>
</script>
<template>
    <h1>Hai Component</h1>
</template>
<style></style>

src/App.vue
<script>
import Hello from './components/Hello.vue';
import Hai from './components/Hai.vue'

// options api 
export default {
    // Registring components/ tell to vue engine to create component
    components: {
        //Hello: Hello
        Hello,
        Hai
    }
}

</script>
<template>
    <h1>Application</h1>
    <Hello />
    <Hai />
</template>
<style></style>
.....................................................................................
			Component composition with Composition api
.....................................................................................

setup function:
...............
<script>
import Hello from './components/Hello.vue';
import Hai from './components/Hai.vue'

//compostion api: setup function
export default {
    // Registring components/ tell to vue engine to create component
    components: {
        //Hello: Hello
        Hello,
        Hai
    },
    setup() {

    }
}

</script>
<template>
    <h1>Application</h1>
    <Hello />
    <Hai />
</template>
<style></style>

setup  attribute:
.................
<script setup>
import Hello from './components/Hello.vue';
import Hai from './components/Hai.vue'
</script>
<template>
    <h1>Application</h1>
    <Hello />
    <Hai />
</template>
<style></style>
.....................................................................................
.....................................................................................

Assigment-1:
............
Create Layout Components

1.header
   |
   Logo
   SearchPanel
   LoginPanel
2.main
   |
   three sections
    -Vue features
3.Footer
   |
   Sponors
   copyright

You have to try

1.Options api
2.Compositions api with imperative (setup fun) and declarative Patterns (setup attr)
.....................................................................................
			   Component Registrations -Creations
.....................................................................................

A vue component needs to be "registered" so that vue knows to locate its implemnetation when it is encountered in a template.


Two Types Registration:

1.Global Registrat

ion 
   Global Components
2.Local Registration
  Local Components

Application Object:
 It is container object which contains other objects.

How to create Application object?

const app=createApp(rootComponent)

Here "app" is just variable which points application object

Application Object having lot of methods:

app.component()
app.use()
app.provide()
etc...
https://vuejs.org/api/application.html

Global components;

const app=createApp(rootComponent)

import { createApp } from 'vue'

const app = createApp({})

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')
.....................................................................................

How to create global components and use them?

Global components and options API:
.................................

// import './assets/main.css'
import { createApp } from 'vue'
import StatusBar from './components/StatusBar.vue'

import App from './App.vue'

// createApp(App).mount('#app')
const app = createApp(App)

//Global Components
app.component('StatusBar', StatusBar)

app.mount('#app')


.....................
App.vue

//Options Api pattern
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
    components: {
        // StatusBar
    }
}
</script>
<template>
    <StatusBar></StatusBar>
</template>

//Composition api with setup function:
<!-- <script>
// import StatusBar from './components/StatusBar.vue'
export default {
    components: {
        // StatusBar
    }
}
</script>
<template>
    <StatusBar></StatusBar>
</template> -->

<script>
export default {
    components: {
    },
    setup() {

    }
}
</script>
<template>
    <StatusBar></StatusBar>
</template>

//Composition api with setup function:

<script setup>
</script>
<template>
    <StatusBar></StatusBar>
</template>
.....................................................................................

Code Refactoring with main.js:
// import './assets/main.css'
import { createApp } from 'vue'
import StatusBar from './components/StatusBar.vue'

import App from './App.vue'

// // createApp(App).mount('#app')
// const app = createApp(App)

// //Global Components
// app.component('StatusBar', StatusBar)

// app.mount('#app')

//chainining pattern 
createApp(App).component('StatusBar', StatusBar).mount('#app')
.....................................................................................
			  Local Components and Registration
.....................................................................................

Components are registered when the child component is created.

In Options and Compositions setup function:
............................................
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
    components: {
        // StatusBar
    }
}
</script>
<template>
    <StatusBar></StatusBar>
</template> -->

 <script>
export default {
    components: {
    },
    setup() {

    }
}
</script>
<template>
    <StatusBar></StatusBar>
</template>

Compostion setup attribute:
...........................


<script setup>
import StatusBar from './components/StatusBar.vue'
</script>
<template>
    <StatusBar></StatusBar>
</template>
.....................................................................................
			 Global components vs Local components
.....................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").

=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.
....................................................................................
			  ....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).


This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   
	Vue supports both cases , but highly recommened is Pascal Case

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where

App.vue

<script setup>
import Hello from './components/Hello.vue'
</script>
<template>
    <!-- Pascal case -->
    <StatusBar></StatusBar>
    <Hello></Hello>
    <!-- Keb-case -->
    <status-bar></status-bar>
    <hello></hello>
</template>

....................................................................................
			  Vue dev tool
....................................................................................

https://devtools.vuejs.org/guide/installation.html
.....................................................................................
			  Templates
.....................................................................................

Template is representation of "View"
View is runtime representation of User interface.
View is typically DOM tree.

Types of Templates:
1.static template
   It is having pure html code
2.Dynmic template 
  It is template having html code and vue instructions
Vue instructions are special symbols and notations

Template = html + vue instructions(data, events,props)


Data Binding:
............
  Passsing data from the component to View and View to Component

Types of Data binding:
1.Interpolation
2.Property and Props binding
3.Attribute binding
4.Event Binding
5.Two way data binding
6.Class and Style binding
....................................................................................
			  Design patterns behind user interface building

1.Angular follows MVC Design pattern
2.React follows flux design pattern.
3.Vue follows MVC Desgin pattern.

MVC
M-Model-Data
V-View
C-Controller.

Vue and MVC:

<script>
   // M + C ->logic
</script>
<template> 
   View logic 
</template>
<style>
</style>

 Component = {Model+Controller(Script) ,View(template,style)}

...................................................................................
				Interpolation
....................................................................................

Transfering data(state) from (controlller) to View.

State:
  State Can be represented in two ways

1.primitives - numbers,strings,boolean
  let name='subramanian'
  let salary=100
  let isValid=true
2.objects and collections -  literal object,arrays
  
  let profile = {
    id:1,
    name:'Arun'
  }
  let profiles = [{
    id:1,
    name:'Arun'
  },{
    id:2,
    name:'Bala'
  }]
.....................................................................................
SFC pattern:
-Using options api
-Using composition api
  ->with setup function
  ->with setup attribute


Using Options api:
 where we can declare data/state? How to bind in ui.

let options = { 
  data:?
  props: ?
  methods: ?
}
<script> 
export default {
  data:function(){
	
	return {}//state object
  }
}

</script>

data is function, which encapsulation state(Model)
data fuunction must return object which encapuslate "state/model"

syntax

ES 5 way of declaration:
<script> 
export default {
  data:function(){
	
	return {}//state object
  }
}

</script>
ES 6 Way of declaration

<script> 
export default {
  data(){
	
	return {}//state object
  }
}

</script>
eg:
App.vue
<!-- State Using Options API -->

<script>
export default {
    data() {
        //state object
        return {
            name: 'Subramanian'
        }
    }
}
</script>
<template>
    
</template>

How to show the variable inside view (Template)?

Via data binding - interpolation  {{Variable}}

<!-- State Using Options API -->

<script>
export default {
    data() {
        //state object
        return {
            name: 'Subramanian'
        }
    }
}
</script>
<template>
    <h1>Your name is {{ name }}</h1>
</template>

More Data:
..........
<!-- State Using Options API -->

<script>
export default {
    data() {
        //state object
        return {
            firstName: 'Subramanian',
            lastName: 'Murugan',
            status: true,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu'
            },
            points: 100

        }
    }
}
</script>
<template>
    <h1>Your name is {{ firstName }} {{ lastName }}</h1>
    <h2>Status {{ status ? "Available" : "Not Available" }}</h2>
    <h2>Address {{ address.city }} {{ address.state }}</h2>
    <h3>Points {{ points }}</h3>
</template>
.....................................................................................
			 Composition API - Using setup function
....................................................................................

export default {
 
  setup(){

   //return state object.
   return { }
 }

}

App.vue

<!-- State Using Composition  API using setup function -->

<script>
export default {
    setup() {
        return {
            firstName: 'Subramanian',
            lastName: 'Murugan',
            status: true,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu'
            },
            points: 100

        }
    }
}
</script>
<template>
    <h1>Your name is {{ firstName }} {{ lastName }}</h1>
    <h2>Status {{ status ? "Available" : "Not Available" }}</h2>
    <h2>Address {{ address.city }} {{ address.state }}</h2>
    <h3>Points {{ points }}</h3>
</template>

Use case : How to declare state using local variables and return state?

<!-- Composition api using setup function  -->
<script>
export default {
    setup() {
        const firstName = 'Subramanian'
        const lastName = 'Murugan'
        const status = true
        const address = {
            city: 'Coimbatore',
            state: 'Tamil Nadu'
        }
        const points = 100
        return {
            // firstName: firstName,
            // lastName: lastName,
            // status: true,
            // address: address,
            // points: points
            firstName, lastName, status, address, points
        }
    }
}
</script>
<template>
    <h1>Your name is {{ firstName }} {{ lastName }}</h1>
    <h2>Status {{ status ? "Available" : "Not Available" }}</h2>
    <h2>Address {{ address.city }} {{ address.state }}</h2>
    <h3>Points {{ points }}
    </h3>
</template>
..................................................................................
			Using setup attribute
...................................................................................
<!-- Composition api using setup attribute  -->
<script setup>
const firstName = 'Subramanian'
const lastName = 'Murugan'
const status = true
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
const points = 100
</script>
<template>
    <h1>Your name is {{ firstName }} {{ lastName }}</h1>
    <h2>Status {{ status ? "Available" : "Not Available" }}</h2>
    <h2>Address {{ address.city }} {{ address.state }}</h2>
    <h3>Points {{ points }}
    </h3>
</template>
....................................................................................
				Directives
....................................................................................
What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directive enchances exsiting html elements- We extend the functionality of HTML   elements.
  We are going to add new behaviour to the HTML elements.

Custom elements and attributes:
.................................

<h1>hello</h1> -  In built element. It is part of html lanaguge.

HTML Runtime:

 When  html runtime encounters h1 element, it knows how to represent.

<hello>
 When  html runtime encounters hello element,it throws Runtime Error called,
 "UnknowElement" Exception, if UnknownElement Exception is thrown, browser  automatically converts it into  "PlainText" Node , renders it.

In 2007, W3c introduced new feature called "custom element feature", According to custom element, we can introduce custom element.

How to teach browser to understand custom element?
 via "Javascript".

w3c introduced new api called customElements.define("popup-info", PopupInfo);

Custom attributes:
.................

Similar to custom elements we can add custom attribute also, through which we can add new meaning to existing html elements

<div style>
     | 
    built in attribute

<div my-if>
      |
     custom attribute------>js 

In frameworks like angular and vue, we have feature called directives(custom elements and attributes)

<root>
<hello-world>
<status-bar>

Every component is custom element/directive.


<app-drawer> ---|JS Code--->Runs ---renders in the browser....

eg:
<script setup>
import AppDrawer from './components/drawer/AppDrawer.vue'
</script>
<template>
<h1>Drawer App</h1>
<!-- Custom element -->
<app-drawer></app-drawer>
</template>
<style>

</style>

src/componnets/drawer/AppDrawer.vue
<script setup>
</script>
<template>
    <p>Drawer Element</p>
</template>
<style>
</style>

.....................................................................................
.....................................................................................
			Custom Attributes
.....................................................................................

1.Built in element Attributes

 <img src="" alt="">
       |      |
   Attributes - Built in attributes

Browser knows how to put logic to src and alt.

2.Custom attributes on existing html elements

<img customAttribute />
        | 
     custom attribute
How to teach browser to parse custom Attributes 
  "Through Javascript"

eg: Vue rendered page:

<div id="app" data-v-app="">
.....................................................................................
	Vue.js Helps to add Custom attributes on existing elements via "Directives" -				Attribute Directives
.....................................................................................
Vue js attribute directive syntax:

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is

Built in custom elements(custom directives/components)
.......................................................
<Transition>
<TransitionGroup>
<KeepAlive>
<Teleport>
<Suspense>

Special Elements
<component>
<slot>
<template>
....................................................................................
			  v-text and v-html
....................................................................................
v-html: innerHTML 
 inerts data into html element as " Inner HTML"
The same thing we can achive through {{}} interpolation

v-text: innerText
 inserts data into HTML elment as "Inner Text"

v-html and v-text both are same but the data representation is different.
v-html inserts 'HTML Node' Where v-text inserts Plain Text Node.

<script setup>
const name = 'Subramanian'
</script>
<template>
    <h1>Interpolation using mustache notation</h1>
    <h2>Name {{ name }}</h2>
    <h1>Interpolation using Directive -v-html</h1>
    <h2 v-html="`Name ${name}`"></h2>
    <h1>Interpolation using Directive -v-text</h1>
    <h2 v-text="`Name ${name}`"></h2>
</template>
<style></style>
....................................................................................
			v-bind
...................................................................................

V-binds attach html attributes or component values(props) dynamically

Binding : attach value to the attribute.

Types of binding:
.................
1.static binding
2.dynamic binding

1.static binding

<img src="logo.png">

 here the value of src cant be changed once it is rendered.

2.dynamic binding

<img v-bind:src="logo.png">

 here v-bind:src is dynamic binding, that src value can be changed dynamically.

<script setup>
const imgUrl = "/src/assets/logo.svg"
const isEnabled = false
const isHidden = false
</script>
<template>
    <h1>Bind directives</h1>
    <div>
        <h1>Static binding</h1>
        <img src="./assets/logo.svg" height="100" width="100">
    </div>
    <div>
        <h1>Dynamic binding</h1>
        <img v-bind:src="imgUrl" height="100" width="100">
    </div>
    <div>
        <h1>Dynamic binding with enabled and disabled</h1>
        <button v-bind:disabled="isEnabled">Click</button>
    </div>
    <div>
        <h1>Dynamic binding with show and hide</h1>
        <article v-bind:hidden="isHidden">This is article</article>
    </div>

    <h1>Vbind short cut :we dont need to use v-bind every time rather we can use :attribute</h1>

    <div>
        <h1>Dynamic binding</h1>
        <img :src="imgUrl" height="100" width="100">
    </div>
    <div>
        <h1>Dynamic binding with enabled and disabled</h1>
        <button :disabled="isEnabled">Click</button>
    </div>
    <div>
        <h1>Dynamic binding with show and hide</h1>
        <article :hidden="isHidden">This is article</article>
    </div>
</template>
<style></style>
.....................................................................................
				Props - Properties
.....................................................................................
			Component driven Principles
.....................................................................................

>Component is just object.
>Component just represents "UI Widget".

Why Components?

-> Components are used to break large UI into smaller, so that we can resue any where in the app and also out side that means inside another app
   ->Reuseablity is key feature.

->Components encapuslate data , which cant be constant , incase if we reuse them into antoher place.

for eg:
  i am going to create gird component, so here i cant have data for the grid that cant be constant.
  Grid need to be configured based on data, that means i need to pass data from outside to the component.

Components means it should be configurable....

How to configure the component with data?

Via  "props" or property.

Props or property is way of passing data to the component.
...................................................................................
		 Data sharing patterns in vue
.....................................................................................

Data can be shared to the compoent in many ways.

1.Props pattern
   Data is shared to the component from the outside of that component.
   outside means, parent component
   passing data from partent to child
2.State pattern
   Data is encapsulated within component.

Props Pattern
Syntax:

From the parent compoenent template
<template>
   <Child  title="value" :value="variable" />
</template>

  <Child  title="value" :value="variable" />
	   |              |
        props           props="variable"

here title is property which value is static
:value is also property which value is dynamic
.....................................................................................
			 Props -Pattern implementation
....................................................................................

How to pass data from parent component to child component?

Since we have many coding patterns(options api, compositions api)

Props with Options api:

src/components/props/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: {
        ProductDetails
    },
    //product data 
    data() {
        return {
            product: {
                id: 1,
                name: 'Phone',
                category: 'Apple',
                qty: 100,
                model: 'IPHONE 15 plus',
                price: 94000,
                inStock: true
            }
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails  title="Product Details Page" :product="product" />
</template>
<style></style>

src/components/props/ProductDetails.vue

<script>
export default {
    props: ['title', 'product']
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>ID {{ product.id }}</h1>
        <h2>{{ product.name }}</h2>
        <p>Category {{ product.category }}</p>
        <p>Qty {{ product.qty }}</p>
        <p>Price {{ product.price }}</p>
        <p>Stock {{ product.inStock ? "Available" : "Not Available" }}</p>
    </div>
</template>
<style></style>

...................................................................................

Compostition with setup function:
.................................

src/components/props/ProductMaster.vue

<!-- Props with Compostion api with setup function -->
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: {
        ProductDetails
    },
    setup() {
        const product = {
            id: 1,
            name: 'Phone',
            category: 'Apple',
            qty: 100,
            model: 'IPHONE 15 plus',
            price: 94000,
            inStock: true
        }
        return {
            product
        }
    }
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product" />
</template>
<style></style>

src/components/props/ProductDetails.vue

<!-- Props with Compostion api -with setup function -->
<script>
export default {
    props: ['title', 'product'],
    setup() {

    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>ID {{ product.id }}</h1>
        <h2>{{ product.name }}</h2>
        <p>Category {{ product.category }}</p>
        <p>Qty {{ product.qty }}</p>
        <p>Price {{ product.price }}</p>
        <p>Stock {{ product.inStock ? "Available" : "Not Available" }}</p>
    </div>
</template>
<style></style>
....................................................................................
  	  Property access with compostion api with setup attribute
..................................................................................

In order access properties inside setup attribute (part of script)

Vue 3 provides global function "defineProps" , through which you can access properties.

src/components/props/ProductMaster.vue

<!-- compostion api with setup attribute -->
<script setup>
import ProductDetails from './ProductDetails.vue'
const product = {
    id: 1,
    name: 'Phone',
    category: 'Apple',
    qty: 100,
    model: 'IPHONE 15 plus',
    price: 94000,
    inStock: true
}
</script>
<template>
    <h1>Product Master</h1>
    <ProductDetails title="Product Details Page" :product="product" />
</template>
<style></style>


src/components/props/ProductDetails.vue

<!-- Props with Compostion api -with attribute  -->
<script setup>
defineProps(['title', 'product'])
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>ID {{ product.id }}</h1>
        <h2>{{ product.name }}</h2>
        <p>Category {{ product.category }}</p>
        <p>Qty {{ product.qty }}</p>
        <p>Price {{ product.price }}</p>
        <p>Stock {{ product.inStock ? "Available" : "Not Available" }}</p>
    </div>
</template>
<style></style>
....................................................................................
		 What if i want to access properties inside setup function
.....................................................................................

Note:
 if you want to property with in setup function, you have to pass props as a arg.
 props: ['title', 'product'],
    setup(props) {
        console.log(props.title)
    }


<script>
export default {
    props: ['title', 'product'],
    setup(props) {
        console.log(props.title)
    }
}
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>ID {{ product.id }}</h1>
        <h2>{{ product.name }}</h2>
        <p>Category {{ product.category }}</p>
        <p>Qty {{ product.qty }}</p>
        <p>Price {{ product.price }}</p>
        <p>Stock {{ product.inStock ? "Available" : "Not Available" }}</p>
    </div>
</template>
<style></style>

Access properties with in script with setup attribute:

<script setup>
const props = defineProps(['title', 'product'])
console.log(props.title)
</script>
<template>
    <h1>{{ title }}</h1>
    <div>
        <h1>ID {{ product.id }}</h1>
        <h2>{{ product.name }}</h2>
        <p>Category {{ product.category }}</p>
        <p>Qty {{ product.qty }}</p>
        <p>Price {{ product.price }}</p>
        <p>Stock {{ product.inStock ? "Available" : "Not Available" }}</p>
    </div>
</template>
<style></style>
....................................................................................
  	 Property Validation - Compostion api with setup attribute
....................................................................................

Sometimes i want to enforce the property data type validation,which is only for runtime verificaiton.

for eg:

i have property called age
  i define rule for agat that age must be number,it should be string.

defineProperty syntax:

i.simple syntax:

defineProps(['propName','propName'])

in the syntax, we cant enforce property rules.

2.Complex syntax: prop validation rule, default value

defineProps({
   age:Number
   id:[Number,String] // can be string or number
   name: {
    type:String,
    required: true,
    default:'name'
   },
   address: {
     type:Object
     default(rawProps){
	return {
	   city:'newCity'
	}
     }
   },
   status: {
	validator(value){
	   return ['OK','NOTOK,'SUCCESS','Failure'].includes(value)
        }
   }
})

Runtime types:
1.Number
2.String
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol

Eg:

App.vue
<script setup>
import User from './components/props/User.vue';
const name = 'Subramanian'
const someno = 1
</script>
<template>
    <h1>Prop Validation</h1>
    <User :name="name" />
    <!-- App.vue?t=1701327351439:36 [Vue warn]: Invalid prop: type check failed for prop "name". Expected String with value "1", got Number with value 1. 
      at <User name=1 > 
      at <App> -->
    <User :name="someno" />
</template>

src/components/props/User.vue

<script setup>
defineProps({
    // name: String
    name: {
        type: String,
        default: 'Your name'
    }
})
</script>
<template>
    <h1>User</h1>
    <h1>Name {{ name }}</h1>
</template>
....................................................................................
				Boolean casting
....................................................................................

Props with Boolean type have special casting rules to mimic the bevavior of native boolean attributes.

Given <MyComponent/> with following declaration

defineProps({
 disabled:Boolean
})

equivalent of passing :disabled=true
<MyComponent disabled />

equivalent of passing :disabled=false
<MyComponent />


eg:

App.vue
<script setup>
import User from './components/props/User.vue';
const name = 'Subramanian'
const someno = 1
const status = true 
</script>
<template>
    <h1>Prop Validation</h1>
    <User status />
    <User  />
</template>

src/components/User.vue
<script setup>
defineProps({
    // name: String
    name: {
        type: String,
        default: 'Your name'
    },
    status: {
        type: Boolean,
        // default: false
    }
})
</script>
<template>
    <h1>User</h1>
    <h1>Name {{ name }} </h1>
    <h3>Status {{ status }}</h3>
</template>
.....................................................................................
			One way data flow model
.....................................................................................

All props forms a one way data flow model where child components cant update the properties.

			 "props are read only"


src/components/User.vue

<script setup>
const props = defineProps({
    // name: String
    name: {
        type: String,
        default: 'Your name'
    },
    status: {
        type: Boolean,
        // default: false
    }
})
props.name = 'Foo'
</script>
<template>
    <h1>User</h1>
    <h1>Name {{ name }} </h1>
    <h3>Status {{ status }}</h3>
</template>

once if try to update, you will get warning like below.

[Vue warn] Set operation on key "name" failed: target is readonly. Proxy(Object)
...................................................................................
		   State Pattern and Event Handling
...................................................................................

Event Handling:

Event handling is one  of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events are signals triggered by user or syste, send to the operating system, the software or hardware reacts according to the event.

Events are classified into two category.

1.Hardware events
 Triggered by user or system, interacts with hardware devices..
eg:
 Moust events
  onclick,ondbclick,onmouseenter etc...

 Keyboard events
   Onkeypress,onkeydown

 Touch events
   ontouchstart,ontouchend

2.Application events
   Attached with objects called dom objects
   onload,oncomplete.
.....................................................................................
			 How event handling works
.....................................................................................
Event handling has been designed on the design pattern called "pub-sub"  or observer design pattern.

There are two actors:

1.Producer
   The producer is something who publishes events
2.Listeners
   The Listener is someone who listens for event.

In js:
 Listener is function , called as callback function.

function listener(event){
   event.target.value
}
event is object is a  bridge between producer and listener

In js, events are given by language itself.

events are started with "on+eventName" - on+click="listener"

addEventListener('click',listener)
  listeners are plain js functions with event object as parameter.


Frameworks and libs like jquery,angular,react,vue adds abstractions.

We can attach event on any dom element which could be application or hardware event.
...................................................................................

Vue js and event handling:
..........................
Vue attaches events with any element with help of directive- "v-on"

Sytnax:
1.v-on:NameoftheEvent="listener" eg: v-on:click="update"
2.@click="listener" eg @click="update"


Event handling in options api:
.............................
<script>
export default {
    //listener
    methods: {
        onIncrement(evt) {
            console.log('Click')
        }
    }
}
</script>
<template>
    <div>
        <h1>Event Handling in Options Api</h1>
        <button v-on:click="onIncrement">Click</button>
        <button @click="onIncrement">Click</button>

    </div>
</template>


Event handling in composition api-with setup function
......................................................
<script>
export default {
    setup() {
        //listeners
        const onIncrement = (evt) => {
            console.log('Button is click')
        }
        //must be returned 
        return {
            onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>Event handling With Setup Function</h1>
        <button @click="onIncrement">Update</button>
    </div>
</template>


Event handling in composition api-with setup attribute:

<script setup>
//listeners
const onIncrement = (evt) => {
    console.log('Button is click')
}
</script>
<template>
    <div>
        <h1>Event handling With Setup Attribute</h1>
        <button @click="onIncrement">Update</button>
    </div>
</template>
.....................................................................................
	 How to attach more than one listener on single DOM element
.....................................................................................

<div v-on:"eventName=listener" v-on:"eventName=listener">
<div v-on="{mouseenter:OnMouseEnter,onmouseleave:onMouseLeave}" />

<script setup>
const OnMouseEnter = () => {
    console.log('onMouse Enter')
}
const OnMouseLeave = () => {
    console.log('onMouse Leave')
}
</script>
<template>
    <div>
        <div v-on="{ mouseenter: OnMouseEnter, mouseleave: OnMouseLeave }">Touch</div>
    </div>
</template>
....................................................................................
		 How to pass data to the event listener
....................................................................................
const update=(data,event) => {
  console.log(data,event)
}

<script setup>
const update = (data, evt) => {
    console.log(data)
    console.log(evt)
}
</script>
<template>
    <button @click="update('hello', $event)">Update</button>
</template>

When we pass data to the listenter, vue cant pass event implicitly, we have to pass event object explicitly via "$event" which is global event object provided by vue...
..................................................................................
			 State-Reactive State
...................................................................................

What is state?
 State Means data.

How to update or change or mutate the state?

React uses the concept called "pure functions" to change the state.
Angular uses the concept called "Two way data binding" to the change

Vue uses the concept called "Reactive state, Reactivity" to change the change.

Component state consists of reactive javascript object, when you modify them, the view updates automatically.

Through evnet listener, we modify the state of object(reactive),UI Gets rerendered with lastest value.

There are various programming patterns to change state in options and compostion api.

Options api and state mutation:
...............................

data function returns object which is by default "reactive",when ever you change that properties of the object, ui bindings gets updated automatically.

Synatx:

data(){
  //reactive
  return { 
    count:0
  }
}

How to mutate?

methods: {
  onIncrement(){
   //mutate reactive variable
   this.count++ //mutation
  }
}

eg:
<script>
export default {
    data() {
        //reactive variables
        return {
            counter: 0
        }
    },
    methods: {
        onIncrement() {
            this.counter++
        },
        onDecrement() {
            this.counter--
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter App-Using Options API</h1>
        <h3>Counter : {{ counter }}</h3>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>

    </div>
</template>
.....................................................................................
			 Composition API setup function
				   And 
                              State Mutation
.....................................................................................

<script>
export default {
    setup() {
        //state variable
        let counter = 0

        //listener 
        const onIncrement = () => {
            counter++
        }

        return {
            counter,
            onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Mutation-Composition api using Setup function</h1>
        <h2>Counter : {{ counter }}</h2>
        <button @click="onIncrement">+</button>
    </div>
</template>

After running this code,
   Here we are trying to mutate/update the count state variable,there is update
happening but it does not trigger, "view update/view rerender".

The reason because the variables are declared with in setup function is not reactive variables by default. so that view engine will not trigger re render.
.................................................................................

We need to convert the local variables into "reactive" variables.

How to declare reactive state or how to attach reactivity feature?

Composition API reactive methods:
.................................

ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

etc...

ref:
 It is function which returns object  called reactive object, not value.

function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}

It is type script syntax, which says that

ref function takes input as value and its type can be any thing , like number,string,boolean,object,array...

Return type could be based on input type...

Here "T" indicates type

Here "Ref" indicates Return type which is called object.
..
eg:
 let counter = ref(0)

Here counter is just variable not holding value rather holding object reference

eg:
<script>
import { ref } from 'vue'

export default {
    setup() {
        //convert counter into reactive
        let counter = ref(0)

        //listener 
        const onIncrement = () => {
            console.log('onIncrement')
            counter.value++
        }
        const onDecrement = () => {
            console.log('onDecrement')
            counter.value--
        }
        return {
            counter,
            onIncrement,
            onDecrement
        }
    }
}
</script>
<template>
    <div>
        <h1>State Mutation-Composition api using Setup function</h1>
        <h2>Counter : {{ counter }}</h2>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
    </div>
</template>
.....................................................................................
			State Mutation using setup attribute
<script setup>
import { ref } from 'vue'
//convert counter into reactive
let counter = ref(0)
//listener 
const onIncrement = () => {
    console.log('onIncrement')
    counter.value++
}
const onDecrement = () => {
    console.log('onDecrement')
    counter.value--
}
</script>
<template>
    <div>
        <h1>State Mutation-Composition api using Setup function</h1>
        <h2>Counter : {{ counter }}</h2>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
    </div>
</template>
.....................................................................................
Passing values to listener and based on that value how to mutate?
...................................................................................
<script setup>
import { ref } from 'vue'
//convert counter into reactive
let counter = ref(0)
//listener 
const onIncrement = () => {
    console.log('onIncrement')
    counter.value++
}
const onDecrement = () => {
    console.log('onDecrement')
    counter.value--
}
const onIncrementBy = (payload, event) => {
    counter.value += payload
}
</script>
<template>
    <div>
        <h1>State Mutation-Composition api using Setup function</h1>
        <h2>Counter : {{ counter }}</h2>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
        <button @click="onIncrementBy(5, $event)">IncrementBy</button>

    </div>
</template>
.....................................................................................
			Inline Listeners
.....................................................................................

We dont need a separate listener function inside script , we can declare as part of the event binding...


<script setup>
import { ref } from 'vue'
//convert counter into reactive
let counter = ref(0)

const onIncrementBy = (payload, event) => {
    counter.value += payload
}
</script>
<template>
    <div>
        <h1>State Mutation-Composition api using Setup function</h1>
        <h2>Counter : {{ counter }}</h2>
        <button @click="counter++">+</button>
        <button @click="counter--">-</button>
        <button @click="onIncrementBy(5, $event)">IncrementBy</button>

    </div>
</template>
.....................................................................................
		   Mutliple reactive variables
....................................................................................

<script setup>
import { ref } from 'vue'
let like = ref(0)
let dislike = ref(100)

</script>
<template>
    <div>
        <h2>Like : {{ like }} Dislike {{ dislike }}</h2>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
    </div>
</template>
.....................................................................................
			 State and props -  Dynamic props
.....................................................................................

How to pass props from parent component to child dynamically?

App.vue
<script setup>
import Counter from './components/props/Counter.vue';
</script>
<template>
    <Counter />
</template>
<style></style>

src/components/props/Counter.vue - Parent

<script setup>
import { ref } from 'vue';
import CounterDisplay from './CounterDisplay.vue';

const counter = ref(0)

</script>
<template>
    <div>
        <h1>Counter Parent</h1>
        <CounterDisplay :counter="counter" />
        <button @click="counter++">+</button>
    </div>
</template>

src/components/props/CounterDisplay.vue -Child

<script setup>
defineProps({
    counter: {
        type: Number
    }
})
</script>
<template>
    <h1>Counter Child</h1>
    <h2>Counter : {{ counter }}</h2>
</template>
.....................................................................................
			 Reactivity
....................................................................................

What is Reactivity?

 Reactivity is one of the core vue js concept.

Component state are "Reactive javascript object"

The word reactivity means "changing" the state(object), whenever changes happen it publishes some events,based on events, reactions happens.


Programming work flow in general:
................................

int x=10;
int y=20;
int result = x + y;

When you compute this code,the runtime will execute instructions top-down pattern.

if there is change in variable (like x or y), will not update result variable.
  
  -Sequentional programming model.

What if i want to update the "result" variable value automatically when ever x or y changes.

Eg:
 Excel spread sheet is one of the best eg for reactivity programming.

let A1=1
let A2=2
let A3 = A1+A2
console.log(A3)=> 3

Change the value of A2

A2=4
console.log(A3)=> 5

Here when you mutate A1 OR A2, A3 gets updated automatically.

This is what mental model of reactivity programming


We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }
 console.log(A3)
 if changes are dedecuted in A1 and A2 ->We need to rerun(update()
 update()
 console.log(A3)

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Vue Internal Reactivity WorkFlow:

Tracker--->triggers--whenDepChange--->runs update function---returns modified state
	

...................................................................................
			  Vue js and Reactivity

Vue js uses "Reactivity subsystem" in order to track all state variables, when ever which changes happen, it inform the vue engine for re render process..

In large scale we cant really track the reading and writing of local variables like the above example.
There is no any mechanism of doing that in "plain javascript". Instead of local variables what we can do , we can intercept the reading and writing of object propeties.

There are two implementations

1.Intercepting property access in javascript via getters and setters.
2.ES 6 has concept called "Proxies", through which we can track changes object 
properties.

In vue 2, setters and getters are used
In vue 3 ,Proxies are used.

Pseudo-code of Reactive apis in Vue js

function ref(value){
 const refObject={
    get value(){
	track(refObject,'value')
        return value
    }
    set value(newValue){
	value=newValue
	trigger(refObject,'value')
    }

 }
 return refObject
}

const proxy = ref(0)
proxy.value
.....................................................................................
			 ref with  literal object
....................................................................................

<script setup>
import { ref } from 'vue';
const counter = ref({ count: 0 })
console.log(counter)
const onIncrement = () => {
    counter.value.count++
}
</script>
<template>
    <h1>Counter : {{ counter.count }}</h1>
    <button @click="onIncrement">+</button>
</template>
.....................................................................................
			 reactive api
.....................................................................................

There is another api to declare reactive state, with "reactive" api.

Unlike "ref" which wraps inner value in special object, reactive makes object itself is reactive.

<script setup>
import { reactive } from 'vue';
const counter = reactive({ count: 0 })
const onIncrement = () => {
    counter.count++
}
</script>
<template>
    <h1 @click="onIncrement">Counter : {{ counter.count }}</h1>
</template>

ref vs reactive:
1.reactive api takes object as parameter, like literal object, collection types such as array,map,set.
It cant hold primitive types such as string,number,boolean..

2.ref can take any type of data as parameter.
....................................................................................
			Deep nested Object changes

=>Reactive conversion(changes) are even updated for deep nested object properties
=>Reactive api compares every property in the object before ui is re rendered for changes

let obj= { 
 a:1
 b:{
   c: {
    d:{
      e:0
    }
   }
 }

}

eg:
<script setup>
import { reactive } from 'vue';

const comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})

</script>
<template>
    <div>
        <h1>Reactive State Nested Object</h1>
        <h1>Like {{ comments.like }} Dislike {{ comments.dislike }} Rating {{ comments.recommend.rating.value }}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
....................................................................................
	    How to avoid deep conversion with Reactive Nested Object
...................................................................................

Some times i am going to update only outter properties, but by default vue enjine compares every property in the object, which degrades performance.

There is an api which is built on the top of "reactive" called "shallowReactive"

shallowReactive:
  Shallow version of reactive().

Unlike reactive there is no deep conversion, only root properties are reactive...

<script setup>
import { reactive, shallowReactive } from 'vue';


//here i want to update only like and dislike, nested properites like rating,rating.value those properties dont want to change.
//reactive function compares every property by default,
// i dont want to compare nested properties for mutation.
// const comments = reactive({
//     like: 0, dislike: 0, recommend: {
//         rating: {
//             value: 0
//         }
//     }
// })
//shallowReactive will ommit nested property validation
const comments = shallowReactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})


</script>
<template>
    <div>
        <h1>Reactive State Nested Object</h1>
        <h1>Like {{ comments.like }} Dislike {{ comments.dislike }} Rating {{ comments.recommend.rating.value }}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
...................................................................................
		 Reactivity,State Mutation,Object Destructuring
...................................................................................
<script setup>
import { reactive } from 'vue';

const { like, dislike, recommend } = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})



</script>
<template>
    <div>
        <h1>Reactive State Nested Object</h1>
        <h1>Like {{ like }} Dislike {{ dislike }} Rating {{ recommend.rating.value }}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
        <button @click="recommend.rating.value++">Rating</button>

    </div>
</template>

After running this code, you will see nothing happens,
   
   "Reactivity is lost once if the object is destructured"

What if i want to destructure but i want reactivity aswell?

1.toRef - single property
2.toRefs - multiple properties


<script setup>
import { reactive, toRefs } from 'vue';

//destructuring with toRef or toRefs
const { like, dislike, recommend } = toRefs(reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
}))
const onDislike = () => {
    dislike.value++
}

</script>
<template>
    <div>
        <h1>Reactive State Nested Object</h1>
        <h1>Like {{ like }} Dislike {{ dislike }} Rating {{ recommend.rating.value }}</h1>
        <button @click="like++">Like</button>
        <button @click="onDislike">Dislike</button>
        <button @click="recommend.rating.value++">Rating</button>

    </div>
</template>
.....................................................................................
			  Watchers
....................................................................................
What is watcher?
  Watcher is a function which allows us to monitor an application state and trigger actions based on those changes.
  Watchers that allow us to observe some data and perform sepcific actions when it changes.
  It is more generic way to observe and react to data changes in the vue instance.

With watchers, we are not just able to watch a property and peform custom actions, we can alos access the old value that is particular property is changining from, as well as the new value that it has changed to.
 
Watchers in options api:
........................
<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    watch: {
        counter(newValue, oldValue) {
            console.log(`Old value=>`, oldValue, 'newValue=>', newValue)
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
    </div>
</template>
.....................................................................................
			Watchers in Compostion api using setup function
....................................................................................
<script>
import { ref, watch } from 'vue';

export default {
    setup() {
        const counter = ref(0)

        //watcher 
        watch(counter, (newValue, oldValue) => {
            console.log(`Old value=>`, oldValue, 'newValue=>', newValue)
        })

        return {
            counter
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
    </div>
</template>
....................................................................................
			Watchers in Compostion api using setup attribute
....................................................................................
<script setup>
import { ref, watch } from 'vue';
const counter = ref(0)
//watcher 
watch(counter, (newValue, oldValue) => {
    console.log(`Old value=>`, oldValue, 'newValue=>', newValue)
})
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
    </div>
</template>
.....................................................................................
			Object properties and watchers
...................................................................................
Watchers will tigger only when data is changed,meaning once the the user starts interacting or if any changes are deducted..

we may want to perform certain actions with inital value of the property we are watching for. 
Our app might require that we send an API request with inital data and then repeat the the process if the data changes...

watch(comments,(newValue,Oldvalue)=>{},{deep:true})
watch(comments,(newValue,Oldvalue)=>{},{immediate:true})

<script setup>
import { reactive, watch } from 'vue';
const comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
//To watch all properties including nested properties
// watch(comments, (newValue, oldValue) => {
//     console.log(`Old Value=>`, oldValue.recommend.rating.value)
//     console.log(`new Value=>`, newValue.recommend.rating.value)

// })
// //To disable to watch all nested properties
// watch(comments, (newValue, oldValue) => {
//     console.log(`Old Value=>`, oldValue.recommend.rating.value)
//     console.log(`new Value=>`, newValue.recommend.rating.value)
//     // console.log(`Old Value=>`, oldValue)
//     // console.log(`new Value=>`, newValue)
// }, {
//     deep: false
// })

// to watch properies once if it is loaded into page
watch(comments, (newValue, oldValue) => {
    // console.log(`Old Value=>`, oldValue.recommend.rating.value)
    // console.log(`new Value=>`, newValue.recommend.rating.value)
    console.log(`Old Value=>`, oldValue)
    console.log(`new Value=>`, newValue)
}, {
    immediate: true
})
</script>
<template>
    <div>
        <h1>Reactive State Nested Object</h1>
        <h1>Like {{ comments.like }} Dislike {{ comments.dislike }} Rating {{ comments.recommend.rating.value }}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>
    </div>
</template>
...................................................................................
			watch is simplified with "watchEffect" api
...............................................................................
<script setup>
import { ref, watch, watchEffect } from 'vue';
const counter = ref(0)

//watch function
// watch(counter, (newValue, oldValue) => {
//     console.log(`oldvalue`, oldValue, 'newValue', newValue)
// })
//watch effect
watchEffect(() => {
    console.log("Watching...", counter.value)
})
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
    </div>
</template>
....................................................................................
			Watchers in Real time
....................................................................................

Use cases:
1.Real time Conversion
2.Real time data fetch

Data Computation in real time:

<script setup>
import { ref, watch } from 'vue';

const tmpCelsius = ref(0)
const tmpFarenheit = ref(0)

watch(tmpCelsius, newValue => {
    tmpFarenheit.value = Math.round((newValue * 9) / 5 + 32)
})
</script>
<template>
    <h1>tmpFarenheit {{ tmpFarenheit }}</h1>
    <button @click="tmpCelsius += 3">tmpFarenheit</button>
</template>
.....................................................................................
			 List Rendering -Arrays
...................................................................................
Arrays:
 =>Arrays are basic data structure which is used to render colleection of data.

Arrays and UI:
 if yo want to render list of data, you can use array.

Arrays are used to build ui layouts

1.ListView
2.CardView
3.GridView..

<script setup>
import { reactive } from 'vue';
import { TODOS } from './mock-data/todos'
const todos = reactive(TODOS)
</script>
<template>
    <div>
        <ul>
            <li v-for="todo in todos">
                <span>{{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
...................................................................................
			  List With Index
...................................................................................

<script setup>
import { reactive } from 'vue';
import { TODOS } from './mock-data/todos'
const todos = reactive(TODOS)
</script>
<template>
    <div>
        <ul>
            <li v-for="(todo,index) in todos">
                <span>{{index}} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
.....................................................................................
			 key
....................................................................................

if there is re ordering in the list when we do some changes like sorting,filtering, vue uses an algorthim called "path"

We can tell to that algorthim for rearrange, that is where "key" attribute comes into picture.

"key's value must be unique"
<script setup>
import { reactive } from 'vue';
import { TODOS } from './mock-data/todos'
const todos = reactive(TODOS)
</script>
<template>
    <div>
        <ul>
            <li v-for="(todo, index) in todos" :key="todo.id">
                <!-- <span>{{ index }} {{ todo.title }}</span> -->
                <span>{{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
.....................................................................................
			  Array Mutations
.....................................................................................

Push,remove,update array elements

<script setup>
import { reactive } from 'vue';

const todos = reactive([])

const addItem = evt => {
    todos.push({ id: Math.random(), text: 'Learn Vue' })
}

</script>
<template>
    <div>
        <ul>
            <li v-for="todo in todos">
                <span>{{ todo }}</span>
            </li>
        </ul>
        <button @click="addItem">Add Todo</button>
    </div>
</template>
.....................................................................................

In Vue all array apis will not trigger render cycle.. API which triggers render cycle- Mutataing apis.

push
pop
shift
unshift
splice
sort
reverse
.....................................................................................
			Displaying filtered and sorted arrays
.....................................................................................
Some times we want to show filtered or sorted version of an array without mutating or resetting orginal data.


We are going to use array immutable api

What is immutable api?
 
 Whe ever we do any changes on object, instead of chaning original object changes, which creates a new copy of the object-immutable.

for eg, if you add new item into array, the runtime will create new array instead of mutating orginal memory.

Array immutable api:
map, filter,reduce
or
you can use spread operator or Object.assign method.

<script setup>
import { ref } from 'vue';
import { TODOS } from './mock-data/todos'
const todos = ref(TODOS)

const filter = () => {
    todos.value = todos.value.filter(todo => todo.completed)
}
</script>
<template>
    <div>
        <button @click="filter">Filter By Status</button>
        <h1>Total Todo items {{ todos.length }}</h1>
        <ul>
            <li v-for="todo in todos" :key="todo.id">
                <span>
                    {{ todo.title }} {{ todo.completed ? "Completed" : "Not Completed" }}
                </span>
            </li>
        </ul>
    </div>
</template>
.....................................................................................
			 Computed Properties
.....................................................................................
In Vue js , there are serveral ways to set static or dynamic values to display on the template.

These inlcude using text interpolation, directly hardcoding into your HTML or even using simple expressions to modify the data.

What  are computed properties?

 In vue js, computed properties enable you to create a property that can be used to modify,manuipulate, and display data within your components in a readable and efficient manner.

You can use computed properties to calculate and display values based on a value or set of values in the data model.

It can also have some custom logic that is cached based on its dependencies, even though page reloads, it does not change..


Eg:
Computed properties in options api:
...................................
Without computed property:
<script>
export default {
    data() {
        return {
            productNo: 2
        }
    }
}
</script>
<template>
    <h1>{{ 'Your Product No ' + productNo }}</h1>
</template>

With Computed Property:
......................
<script>
export default {
    data() {
        return {
            productNo: 2
        }
    },
    computed: {
        product() {
            return `Your Product No is ${this.productNo}`
        }
    }
}
</script>
<template>
    <h1>{{ product }}</h1>
</template>

Use cases of computed properties:
..................................
Computed properties are used to solve more complex template expression problems.

1.Filtering data
 computed properties are great for filtering data.

for eg: lets say you are filtering an array from input search bar.
<script>
import { TODOS } from './mock-data/todos'

export default {
    data() {
        return {
            todos: TODOS,
            searchQuery: null
        }
    },
    computed: {
        resultQuery() {
            if (this.searchQuery) {
                //filter logic 
                return this.todos.filter(item => {
                    console.log(item)
                    return this.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
                });
            } else {
                return this.todos
            }
        }
    }
}
</script>
<template>
    <input v-model="searchQuery" type="text">
    <div v-for="todo in resultQuery" :key="todo.id">
        <p>{{ todo.id }} {{ todo.title }}</p>
    </div>
</template>
.....................................................................................
			Dynamic computations

<script>
export default {
    data() {
        return {
            number: 2
        }
    },
    computed: {
        doubleIt() {
            return this.number * 2
        }
    }
}
</script>
<template>
    <h1>Value {{ doubleIt }}</h1>
    <button @click="number++">{{ number }}</button>
</template>
.....................................................................................
			 Dynamic Toggling
.....................................................................................
<script>
export default {
    data() {
        return {
            number: 2,
            status: true
        }
    },
    computed: {
        doubleIt() {
            return this.number * 2
        },
        toggle() {
            if (this.status) {
                return true
            } else {
                return false
            }

        }

    }
}
</script>
<template>
    <h1>Value {{ doubleIt }}</h1>
    <button @click="number++">{{ number }}</button>
    <button @click="status = !status">{{ status }}</button>
</template>
.....................................................................................
			 Composition api and computed properties
....................................................................................

setup fun and set attribute computed properties remains same.

<script setup>
import { computed, ref } from 'vue'
const product = ref(2)
const productNo = computed(() => {
    return `Your Product No is ${product.value}`
})
</script>
<template>
    <h1>{{ productNo }}</h1>
</template>


<script setup>
import { computed, reactive } from 'vue'

import { TODOS } from './mock-data/todos'

const state = reactive({ todos: TODOS, searchQuery: null })

const resultQuery = computed(() => {
    if (state.searchQuery) {
        //filter logic 
        return state.todos.filter(item => {
            console.log(item)
            return state.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
        });
    } else {
        return state.todos
    }
});
</script>
<template>
    <input v-model="state.searchQuery" type="text">
    <div v-for="todo in resultQuery" :key="todo.id">
        <p>{{ todo.id }} {{ todo.title }}</p>
    </div>
</template>
...................................................................................
			Caching and computed Properties
		   (Normal methods vs Computed Properties)


We can write same logic using normal methods, but normal methods are not cached


<script setup>
import { computed, reactive } from 'vue'

const author = reactive({
    name: 'Subramanian',
    trainings: [
        'vue',
        'react',
        'java'
    ]
})
//computed Properties:
const TotalTrainings = computed(() => {
    console.log('computed  method')
    return author.trainings.length > 0 ? "Yes" : "No"
})

//computed properties
const TotalTrainingsNormal = () => {
    console.log('TotalTrainingsNormal  method')
    return author.trainings.length > 0 ? "Yes" : "No"
}
</script>
<template>
    {{ TotalTrainings }}
    {{ TotalTrainings }}
    {{ TotalTrainings }}
    <!--  -->
    {{ TotalTrainingsNormal() }}
    {{ TotalTrainingsNormal() }}
    {{ TotalTrainingsNormal() }}
</template>
.....................................................................................
			   Data Sharing Patterns
.....................................................................................

How to share data among vue components?

There are three ways of sharing data 

1.Parent to child - Props pattern
2.Child to Parent - Event Emittern Pattern.
3.Across the application - Global Pattern
....................................................................................
			Child to Parent -Event Emitter Pattern
....................................................................................

Child component can share data to its parent via events.

Syntax:

Child Component:

const emit = defineEmits(['change','remove','save'])

emit('NameofEvent',data)

Parent Component:

Template:
 <Child @on-nameofEvent="listener"/>

const listener = data=> { 
   console.log(data)
}

Eg:

src/components/eventsemitter/Counter.vue

<!-- Child Component -->
<script setup>
import { ref } from 'vue';

const counter = ref(0)
const emit = defineEmits(['onReqest'])

const onSend = () => {
    counter.value++
    emit('onRequest', counter.value)
}

</script>
<template>
    <h1>Child Component -Counter</h1>
    <button @click="onSend">SendToParent</button>
</template>

src/App.vue
<!-- Parent which receives events from child -->
<script setup>
import { ref } from 'vue';
import Counter from './components/eventsemitter/Counter.vue';

const childValue = ref(0)
const getChildData = data => {
    childValue.value = data
}
</script>
<template>
    <h1>Parent Counter {{ childValue }}</h1>
    <Counter @on-request="getChildData" />
</template>
.....................................................................................
			CSS integration
.....................................................................................

CSS types

1.Global Styles
2.Component spcific styles

Global Styles:

assets/app.css

body {
    background-color: antiquewhite;
    margin-left: 50px;
    margin-top: 50px;
}

h1 {
    font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}

h2 {
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
}
...................................................................................

How to add thrid party css frameworks like bootstrap?

npm install bootstrap

main.js
import 'bootstrap/dist/css/bootstrap.min.css'

.....................................................................................
		      Dynamic Styling
....................................................................................

How to bind css class dynamically

static class :

<div class="container">

Dynamic class:
<div :class="{box:isActive}"></div>

Apply box class based on "isActive" property.

<script setup>
import { reactive, ref } from 'vue';
const isActive = ref(false)

const classObject = reactive({
    active: false,
    bgcolor: false
})

const highLight = () => {
    if (isActive.value) {
        isActive.value = false
    } else {
        isActive.value = true
    }
}
const clickActive = () => {
    if (classObject.active) {
        classObject.active = false
        classObject.bgcolor = false

    } else {
        classObject.active = true
        classObject.bgcolor = true

    }
}

</script>
<template>
    <div @mousemove="highLight" :class="{ active: isActive, bgcolor: isActive }">
        <h1>Hello</h1>
    </div>

    <div @click="clickActive" :class="classObject">
        <h1>Hello</h1>
    </div>
</template>
<style>
/* Local component specific style */
.active {
    color: red;
}

.bgcolor {
    background-color: aqua;
}
</style>
.....................................................................................
			Advanced Props
.....................................................................................

Already we have seen props, now we will discuss more advanced properties

1.Dynamic props - State as prop
2.HTML Attributes as prop- Fall through attributes.
3.Component/DOM element as Prop - Slots

.....................................................................................
		HTML Attributes as prop- Fall through attributes.
....................................................................................

Attribute Inheritance: (HTML attributes(class) as Prop):
.........................................................

A Fall throuh attribute is an  attribute or v-on listeners that is passed to component but it is not explcitly declared in the receiving components(child components) via props or emits.

		Properties which are inherited from the parent to child 
			"class,style, and id attributes"

src/App.vue
<script setup>
import { ref } from 'vue';
import MyButton from './components/attributeinheritance/MyButton.vue'

const title = ref('click')
</script>
<template>
    <div class="container">
        <h1>Parent</h1>
        <MyButton :title="title" class="fancy-btn"></MyButton>
    </div>
</template>
<style>
.fancy-btn {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline;
    font-size: 16px;
}
</style>

src/components/attributeinheritance/MyButton.vue

<script setup>
import { useAttrs } from 'vue';

const props = defineProps(['title'])

</script>
<template>
    <button>{{ title }}</button>
  
</template>
<style></style>

Now we can see the output the button automatically inherited the property..
via special variable called "attrs"...

if you want to access those attributes inside script...

<script setup>
import { useAttrs } from 'vue';

const props = defineProps(['title'])
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
    <button>{{ title }}</button>
</template>
<style></style>

if you wan to access attributes inside template.....

<script setup>
import { useAttrs } from 'vue';

const props = defineProps(['title'])
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
    <!-- <button>{{ title }}</button> -->
    <!-- <span>{{ $attrs }}</span> -->
    <span>{{ attrs }}</span>
</template>
<style></style>
...................................................................................

What if i have container elements?

<div>
  <button>{{ title }}</button>
</div>

Now you can see output is applied to only div element not button element.

What if i want to apply

we need to bind explicitly using "v-bind="$attrs"

<div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
</div>

What if i have multiple elements to apply the same style?
 <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>

eg:

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>
</template>
<style></style> 
....................................................................................
	 Can we override parent class attribute in child component
....................................................................................
Yes, but default which is not overriden.

How to override?

Scoped style.
<!-- <script setup>
import { useAttrs } from 'vue';

const props = defineProps(['title'])
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
     <button>{{ title }}</button> -->
    <!-- <span>{{ $attrs }}</span> -->
    <!-- <span>{{ attrs }}</span>
</template>
<style></style> --> 

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button>
</template>
<style scoped>
.fancy-btn {
    background-color: #4c56af;   
}
</style> 
....................................................................................
		What if  i dont want attribute inheritance
...................................................................................

If your template is having more elements, attribut inheritance cant be stopped.
if your template having single element , it can be stopped.

<script setup>
const props = defineProps(['title'])
defineOptions({
    inheritAttrs: false
})
</script>
<template>
    <!-- <div style="background-color: ;">
        <button v-bind="$attrs">{{ title }}</button>
    </div>
    <button v-bind="$attrs">{{ title }}</button>
    <button v-bind="$attrs">{{ title }}</button> -->
    <button>{{ title }}</button>
</template>
<style scoped>
.fancy-btn {
    background-color: #4c56af;
}
</style> 
...................................................................................
				 Slots
		Component as Prop or DOM element as Prop
...................................................................................

How to represent components?

<MyComponent/> -  Component has no children

<MyComponent>
        ? - Child elements - It could be dom element or another component
</MyComponent>



<MyComponent>
        ? - You are sending html element or another component => Slot content
</MyComponent>

In order to access element or component as prop inside child component vue offeres butin component "slot" - Which is place holder where the elements to be inserted.

Parent Component: App.vue
<script setup>
import ChildSlot from './components/slots/ChildSlot.vue';

</script>
<template>
    <div class="container">
        <h1>Parent</h1>
        <ChildSlot>
            <!-- PASS DOM element as Prop -->
            <h1>DOM Element as Prop</h1>
        </ChildSlot>
    </div>
</template>

src/components/slots/ChildSlot.vue
<script setup>
</script>
<template>
    <div>
        <h1>Child</h1>
        <hr>
        <slot></slot>
    </div>
</template>
.....................................................................................
				Fallback Content
....................................................................................

What if i dont want to pass "element/component" as prop, if you want to display something if you dont pass-fallback.

<div>
    <ChildSlot>
	<h1>Here we are passing element</h1>
    </ChildSlot>
</div>


<div>
    <ChildSlot>
	<!--No element is passed-->
    </ChildSlot>
</div>


eg:
App.vue
<script setup>
import ChildSlot from './components/slots/ChildSlot.vue';

</script>
<template>
    <div class="container">
        <h1>Parent</h1>
        <ChildSlot>
            <!-- PASS DOM element as Prop -->
            <h1>DOM Element as Prop</h1>
        </ChildSlot>

        <ChildSlot>
            <!-- Here no element is passed -->
        </ChildSlot>
    </div>
</template>


src/components/slots/ChildSlot.vue
<script setup>
</script>
<template>
    <div>
        <h1>Child</h1>
        <hr>
        <slot>
            <h1>Fallback</h1>
        </slot>
    </div>
</template>
....................................................................................
			Can we pass Component as Prop
....................................................................................


src/components/slots/Panel.vue
<script setup>
</script>
<template>
    <div>
        <slot></slot>
    </div>
</template>

src/components/slots/Image.vue
<script setup>
</script>
<template>
    <div>
        <img src="../../assets/logo.svg" height="100" width="100">
    </div>
</template>

App.vue
<script setup>
import Image from './components/slots/image.vue'
import Panel from './components/slots/Panel.vue'
</script>
<template>
    <div>
        <Panel>
            <!-- Image as prop -->
            <Image />
        </Panel>
    </div>
</template>
.....................................................................................				  Multi Slot
..................................................................................


We can have more than one slot:

Without slot:
<Layout>
   <Header/>
   <Body/>
   <Footer/>
</Layout>

With Slot:

<Layout>
   <Header>
	<!--Header Information -->
   </Header>
   <Body>
	<!--Body Information -->
   </Body>
   <Footer>
	<!--Footer Information -->
  </Footer>
</Layout>

Eg:
 Child
  <slot name="header"></slot>

 Parent
  <template v-slot:header></template>


eg:
App.vue
<script setup>
import Layout from './components/slots/Layout.vue';
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- Nested Templates -->
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:body>
            <h1>Body</h1>
        </template>
        <template v-slot:footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>

src/components/slots/Layout.vue

<script setup>
</script>
<template>
    <div>
        <header>
            <slot name="header">
                <h1>Default Header</h1>
            </slot>
        </header>
        <main>
            <slot name="body">
                <p>Default main</p>
            </slot>
        </main>
        <footer>
            <slot name="footer">
                <p>Default footer</p>
            </slot>
        </footer>
    </div>
</template>
....................................................................................
		  Without V-Slot directive, we can use  #Name
....................................................................................

With vslot directive.
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- Nested Templates -->
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:body>
            <h1>Body</h1>
        </template>
        <template v-slot:footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>

without v-slot directive: using #name
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template #header>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
.....................................................................................				   Default Slots
....................................................................................

The slot without name is called "default slot".

In case of multi slot, we can make any one slot as default one.

Child:
<script setup>
</script>
<template>
    <div>
        <header>
            <!-- <slot name="header">
                <h1>Default Header</h1>
            </slot> -->
            <!-- Default slot -->
            <slot>
                <h1>Default Header</h1>
            </slot>
        </header>
        <main>
            <slot name="body">
                <p>Default main</p>
            </slot>
        </main>
        <footer>
            <slot name="footer">
                <p>Default footer</p>
            </slot>
        </footer>
    </div>
</template>

In the parent:
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template #header>
            <h1>Header</h1>
        </template> -->
        <template #default>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>
.....................................................................................
				Dynamic slots
.....................................................................................

The slot names can be dynamic, that means we can add slot name via reactive 

Static slot:
<template v-slot:header>
<template #header>
<template #default>

Dynamic slots:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>


eg:

<script setup>
import { ref } from 'vue';
import Layout from './components/slots/Layout.vue';

const header = ref('header')
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template #[header]>
            <h1>Header</h1>
        </template>
        <template #default>
            <h1>Header</h1>
        </template>
        <template #body>
            <h1>Body</h1>
        </template>
        <template #footer>
            <h1>Footer</h1>
        </template>
    </Layout>
</template>

....................................................................................
			   Slots Scope
....................................................................................
Slots scope enable data accssibility(sharing) for parent and child components.

There are two slot scope
1.Render scope
2.Scoped slots

Render Scope:
............
Slot content has access to the data scope of the parent component, because it is defined in the parent. For example:

<span>{{ message }}</span>
<FancyButton>{{ message }}</FancyButton>

Here both {{ message }} interpolations will render the same content.

Slot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:

Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.

	 "As rule of thumb every thing in the template compiled in the parent scope;
          every thing is compiled in the child template in the child scope"



Scoped Slots:
.............
   if you want to access data in the parent and child scope.

  "if parent component want to access child  state(data),the child can pass data to   parent via "slot" when rendering it"

  Slot can act as bridge between parent and child for data transfer.

Syntax:
 <slot :firstName="firstName" :age="age" />

eg:

src/components/slots/SchopedSlot.vue

<script setup>
import { ref } from 'vue';

const message = ref('Hello')
</script>
<template>
    <!-- Send data to the parent -->
    <slot :message="message"></slot>
</template>


App.vue

<script setup>
import SchopedSlot from './components/slots/SchopedSlot.vue';
</script>
<template>
    <SchopedSlot v-slot="slotProps">
        {{ slotProps.message }}
    </SchopedSlot>
</template>
.....................................................................................
		*************************************************************************************
**************************************************************************************			 Dependency Injection: Composition API
....................................................................................

Prop Driling:

 When you pass data from the parent component to child, from child to its child and so on, at each level you have to pass props manually

    			Root
			 |
			 props
			 |
			Child1
			 |props
			Child2
			 |props
			Child3
			 |props
		        Child-N


<script setup>
import { ref } from 'vue';
import Child1 from './propsdrilling/Child1.vue';
const message = ref('Hello')
</script>
<template>
    <h1>Root</h1>
    <Child1 :message="message" />
</template>

Child1.vue
<script setup>
import Child2 from './Child2.vue';
const props = defineProps(['message'])
</script>
<template>
    <h1>Child 1</h1>
    <Child2 :message="props.message" />
</template>

Child2.vue
<script setup>
import Child3 from './Child3.vue';
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 2</h1>
    <Child3 :message="props.message" />
</template>

Child3.vue
<script setup>
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
</template>

What if  i want to access the data which is supplied in the root component into the deepest child component.

We can solve props drilling with "provide and inject".

Parent component can act as dependency provider to all its decendants.

Any component in the decendants tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.


  			Root -  Provide
			 |        |
			props     |
			 |        |
			Child1    |
			 |        |
			Child2    |
			 |        |
			Child3    |
			 |        |
		        Child-N - Inject

eg:

Parent : App.vue

<script setup>
import { provide, ref } from 'vue';
import Child1 from './components/propsdrilling/Child1.vue';
const message = ref('Hello')
provide("message", message)
</script>
<template>
    <h1>Parent</h1>
    <Child1 ></Child1>
</template>
<style>

</style>

Child1.vue
<script setup>
import Child2 from './Child2.vue';

</script>
<template>
    <h1>Child1</h1>
    <Child2></Child2>
</template>
<style>

</style>

Child2.vue
<script setup>
import Child3 from './Child3.vue';

</script>
<template>
        <h1>Child2</h1>

    <Child3></Child3>
</template>
<style>
</style>

Child3.vue
<script setup>
import { inject } from 'vue';

const message = inject('message')
</script>
<template>
    <h1>Child3</h1>
    <h1>Data From the Parent {{message}} </h1>
</template>
<style>

</style>

What if multiple properties to be passed ?

// provide("message", message)
// provide("counter",counter)

provide('info',{counter,message})


const message =inject('message')
const {message,counter} =inject('info')

what if i dont provide?
 we can have default values

const message = inject('message','default Message')

.....................................................................................
....................................................................................
Provide and inject is used to share data in the component tree.
Provide and inject can also be used to share data globally.

How to share data globally?
 with help of application/app object 

app.provide			

...................................................................................
			            App Level Data sharing

You have to provide via app object.

app.provide('company','google')

main.js
import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .mount('#app')

In any component:
<script setup>
import { inject } from 'vue'
const props = defineProps(['message'])

// const name = inject('name', 'default Name')
// const counter = inject('counter', 0)
const { name, counter } = inject('info')
const company = inject('company')
</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
    <h1>Tree level Global Data {{ name }} {{ counter }}</h1>
    <h1>App level Global Data {{ company }}</h1>

</template>

...................................................................................
			can we mutate the provider data


Yes we can override the provider data in child component

let companyName = inject('companyName')

companyName = 'Google'

What if i dont want to override? how to declare provider data read only.

App.v
<script setup>
import { provide, ref, readonly } from 'vue';
import Child1 from './components/providers/Child1.vue';
const message = ref('Hello')
provide('message', readonly(message))
</script>
<template>
    <h1>Root</h1>
    <Child1 />
</template>

Child3:
<script setup>
import { inject } from 'vue';
// const message = inject('message')
//default value
// const message = inject('message','default Message')

let message = inject('message')

let companyName = inject('companyName')
console.log(message)
message.value = 'How are you'

console.log(message)
</script>
<template>
    <h1>Child 3 {{message }}  {{companyName }}</h1>
</template>

.................................**************************..........................
			  Form Handling
.....................................................................................

Form Controls:
1.text / password
2.Multi line text
3.checkbox
4.radio
5.select
6.submit
7.reset

How to get input from the keyboard via form controls and bind in the ui


Syntax:

<input @input="listener" >
<script setup>

const getInput = ()=>{

}

</script>
<template>
    <h1>Forms</h1>
    <input @input="getInput" />
</template>
<style>

</style>

How to read value from the form controls?

1.using event object
2.using two way data binding

1.using event object
<script setup>

const getInput = evt=>{
  const value = evt.target.value
  console.log(value)
}

</script>
<template>
    <h1>Forms</h1>
    <input @input="getInput" />
</template>
<style>

</style>

How to bind data which got from keyboard?

<script setup>
import { ref } from 'vue';

const name = ref('')

const getInput = evt=>{
  const value = evt.target.value
  console.log(value)
  name.value = value
}

</script>
<template>
    <h1>Forms</h1>
     <p>{{name}}</p>
    <input @input="getInput" />
</template>
<style>

</style>


Two way data binding:

When ever user interacts via typing in the text box, the reactive variable is updated,
when ever reactive variable is updated, the UI is rerendered.

:value property  is used to initalize the default reactive state variable in side text box

<script setup>
import { ref } from 'vue';

const name = ref('default')
const getInput = (evt) => {
    const value = evt.target.value
    console.log(value)
    name.value = value
}
</script>
<template>
    <div class="container">
        <h1>Forms</h1>
        <h1>Name {{ name }}</h1>
        <input @input="getInput" :value="name">
    </div>
</template>


.....................................................................................
				How to reduce listeners
....................................................................................
When we have more input fields, we need to write more event listeners, which can be avoided in two ways

1.inline event listener

<script setup>
import { ref } from 'vue';
const name = ref('default Name')
</script>
<template>
    <h1>Forms</h1>
     <p>{{name}}</p>
    <input @input="evt=>name=evt.target.value" :value="name" />
</template>
<style>

</style>

2.Using v-model directive

 ->It removes explicit event binding ,which attaches the default event handler and event automatically.
 
<script setup>
import { ref } from 'vue';
const name = ref("defaultName")

</script>
<template>
    <div>
        <p>{{name}}</p>
        <input v-model="name"/>
    </div>
</template>

v-model directive can be used on other input controls as well.

textarea
  it uses value property and input event

checkbox
radio
  It uses checked property and change event
select
 It uses value property and input event 

TextArea:
..........

Using Text area , we can get multi line input
<script setup>
import { ref } from 'vue';

const mail = ref('')

</script>
<template>
  
    <div>
        <h2>{{ mail }}</h2>
        <label id="mail">Mail</label>
        <textarea v-model="mail" />
    </div>
</template>


Radio:
.....
<script setup>
import { ref, computed } from 'vue';

const choice = ref("Male")


</script>
<template>
    <div>
        <h1>Select any One</h1>
        <input type="radio" id="Male" value="Male" checked v-model="choice" />
        <label for="Male">Male</label>
        <input type="radio" id="Female" value="Female" v-model="choice" />
        <label for="Female">FeMale</label>
    </div>
    <div>
        {{ choice }}
    </div>
</template>



Select:
<script setup>
import { ref, computed } from 'vue';

const selected = ref('')

const courses = ref(["Vue", "React", "Angular", "MicroServices"])

const selectedCourse = ref('')

</script>
<template>
    <div>
        <select v-model="selected">
            <option disabled value>Select Your choice</option>
            <option>Vue</option>
            <option>React</option>
            <option>Angular</option>
            <option>MicroServices</option>
        </select>
    </div>
    <div>
        {{ selected }}
    </div>
    <hr />
    <div>
        <select v-model="selectedCourse">
            <option disabled value>Select Your choice</option>
            <option v-for="course of courses">{{ course }}</option>
        </select>
    </div>
    <div>
        {{ selectedCourse }}
    </div>
</template>
...................................................................................

Value Bindings -vue custom attributes:
......................................

v-model=""
true-value="yes" //replace true or false value into meaningfull values 
false-value="no"

<script setup>
import { ref } from 'vue';
const toggle = ref(true)
const truthyValue="Yes"
</script>
<template>
    <div>
        <input type="checkbox" :true-value="truthyValue" checked false-value="no" v-model="toggle" />
        <label for="Toggle">Toggle</label>
    </div>
    <div>
        <!-- {{toggle ? "Yes" : "No"}} -->
        {{ toggle }}
    </div>
</template>

For Radio button

:true-value=""

For Select options

:value="{text: 'some text'}"

.....................................................................................

....................................................................................
		Form Submission and How to prevent default events
....................................................................................

In java script, when you submit form, automatically there is event is fired , which is called "onSubmit" event.

onSubmit event by default looks the server url to be posted.

      <form action="http://www.google.com">
          <button>Submit</button>
      </form>

Here , the button tries to redirect to the url mentioned in the action property.

I need to control, the form submission manually.

Event Object :

has api called "preventDefault()" , which does not trigger auto form submission.


<script setup>

const onSubmit = event => {
    if (event) {
        event.preventDefault();
    }
}

</script>
<template>
    <div>
        <form action="http://www.google.com">
            <button @click="onSubmit">Submit</button>
        </form>
    </div>
</template>

Vue has some short cuts, instead of giving this inside listener, we can give inside templates.

Event Modifiers:
...............

Event Modifiers are used with v-on

<form @submit.prevent="onSubmit">

</form>

<script setup>

const onSubmit = event => {
    alert('Form to be Submitted')
}

</script>
<template>
    <div>
        <form @submit.prevent="onSubmit">
            <button>Submit</button>
        </form>
    </div>
</template>

Other event modifiers

//event propagation to be stopped
<a @click.stop="listner">

I want to submit form when key board events

<input @keyup.enter="onSubmit">

other keyboard keys modifiers

.enter
.tab
.left
.right
.space
.down
.up

.ctrl
.alt
.shift
.meta
.enter
.....................................................................................
.....................................................................................
				 Component Life Cycles
.....................................................................................

Component has two phases of life cycles

1.mount
     inital render - when component is initalized
2.unmount
    when component is removed
Methods:
 onMounted,onUpdated,onUnMounted

onMounted method is generally and mostly used method
  Used to initalize api calls,timers,websockets connections.

<script setup>
import { onBeforeMount, onMounted, onUpdated, ref } from 'vue';

const counter = ref(0)

onBeforeMount(() => {
    console.log('onBefore Mount')
})
onMounted(() => {
    console.log('onMounted')
})
onUpdated(() => {
    console.log('OnUpdated')
})
</script>
<template>
    <div>
        <h1>Component life cycle methods</h1>
        <span @click="counter++">{{ counter }}</span>
    </div>
</template>
....................................................................................
.....................................................................................
			   API calls in vue
.....................................................................................
Patterns:
1.you can write api call within component
2.you can write api call outside component using composable
3.you can write api call outside component using state management libs

Vue has no any opinion to select lib for making api calls, you can use fetch,axios.

Api calls can be made during inital page render-mounted
Api calls can be made during user interaction.

.....................................................................................
			   Ajax calls/api calls from vue
....................................................................................

API Call with in component:
..........................

<script setup>
import { onMounted, ref } from 'vue';

const data = ref(null)
const error = ref(null)

//function to fetch data
const fetchData = async () => {
    const url = `https://jsonplaceholder.typicode.com/todos`
    try {
        const response = await fetch(url)
        const todos = await response.json()
        //update reactive state 
        data.value = todos
    }
    catch (err) {
        error.value = err
    }
}
//life cycle method 
onMounted(() => {
    // setTimeout(()=>{
    //     fetchData()
    // },5000)
    fetchData()
})

</script>
<template>
    <div>
        <h1>Web Service Call</h1>
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>
.....................................................................................
				Composables - Hooks(in react)
.....................................................................................

What is a "Composable"?
 
  In the context of Vue applications, "Composables" are just plain javascript function that leverages Vue's Composition API to encapuslate and reuse "Stateful logic".

When we building frontend applications, we often need to resuse logic for common tasks. for example we may need to formate dates in many places, so extract a resuable function for that.

Statfull logic is that manage /update state that changes over time.

Lets begin with simple example called mouse tracker.

I need to track mouse pointer position.

<!-- Mouse tracking feature within component -->
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
const x = ref(0)
const y = ref(0)

const update = evt => {
    x.value = evt.pageX
    y.value = evt.pageY
}
onMounted(() => {
    //add dom listener 
    window.addEventListener('mousemove', update)
})
onUnmounted(() => {
    window.removeEventListener('mousemove', update)
})
</script>
<template>
    <h1>Mouse Positions are X: {{ x }} Y: {{ y }}</h1>
</template>


In the example mouse tracking feature is locked with in this component, what if i want the same logic inside another component.

Solution: 
 Composables.

=>Composables is just plan js function
=>composables must be written inside another folder called "composables"
=>file name is "mousetracker.js"

mousetracker.js

 Name of the function should begin "useFunctionName".

export function useMouseTrack() {

}
The function may take args and also may return values...

eg:

src/composables/mousetracker.js
import { onMounted, onUnmounted, ref } from 'vue';

export function useMouseTrack() {
    const x = ref(0)
    const y = ref(0)
    const update = evt => {
        x.value = evt.pageX
        y.value = evt.pageY
    }
    onMounted(() => {
        //dom listener
        window.addEventListener('mousemove', update)
    })
    onUnmounted(() => {
        window.removeEventListener('mousemove', update)
    })
    return {
        x, y
    }
}
src/components/App.vue
<!-- Mouse tracking within component -->
<script setup>
import { useMouseTrack } from './composables/moustracker'
const { x, y } = useMouseTrack()
</script>
<template>
    <h1>Mouse Positions are at X:{{ x }} And Y {{ y }}</h1>
</template>
.....................................................................................
	 As much as possible we have to break the code inside composable

Composable can use another composable.
src/composables/event.js
import { onMounted, onUnmounted, ref } from 'vue';

export function useEventListener(target, event, callback) {

    onMounted(() => {
        //dom listener
        target.addEventListener(event, callback)
    })
    onUnmounted(() => {
        target.removeEventListener(event, callback)
    })
}

	
src/composables/mousetracker.js	
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouseTrack() {
    const x = ref(0)
    const y = ref(0)
    useEventListener(window, 'mousemove', evt => {
        x.value = evt.pageX
        y.value = evt.pageY
    })
    return {
        x, y
    }
}
....................................................................................
			API and Composables-Async State
....................................................................................
....................................................................................
			API and Composables-Async State
....................................................................................

src/composables/fetch.js

import { ref } from 'vue';

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    async function init() {
        try {
            const response = await fetch(url)
            const items = await response.json()
            //update state 
            data.value = items;
        }
        catch (err) {
            error.value = err
        }
    }
    init()
    return {
        data, error
    }
}

src/App.vue
<script setup>
import { useFetch } from './composables/fetch'
const { data, error } = useFetch('https://jsonplaceholder.typicode.com/todos')
</script>
<template>
    <div>
        <h1>Todo App</h1>
        <!-- Conditional rendering : v-if...v..else-if -->
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>

.....................................................................................
			Accepting Reactive state
....................................................................................

 useFetch('https://jsonplaceholder.typicode.com/todos')

  It takes a static URL string as input, so it performs the fetch only once and is then done.

What if we want it to re-fetch whenver the url changes? in order to achive this, we need to pass reactive state into the composable function,and let the composable create watchers that performs actions using the passed state.

const url = 'https://jsonplaceholder.typicode.com/todos' -static url

const url = ref('https://jsonplaceholder.typicode.com/todos') -reactive url.

url.value = '/new-url' - trigers re-fetch

or 
const {data,error} = useFetch(()=> `/todos/${id}`);

eg:
fetch.js 
import { ref, watchEffect, toValue } from 'vue';

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    
    watchEffect(() => {
        data.value = null;
        error.value = null;
        async function init() {
            try {
                //we cant pass reactive variable directly into fetch 
                //we need to convert into value 
                const response = await fetch(toValue(url))
                const items = await response.json()
                //update state 
                data.value = items;
            }
            catch (err) {
                error.value = err
            }
        }
        init()
    })
    return {
        data, error
    }
}

App.vue
<script setup>
import { ref } from 'vue';
import { useFetch } from './composables/fetch'
const url = ref('https://jsonplaceholder.typicode.com/todos')

const { data, error } = useFetch(url)
</script>
<template>
    <div>
        <h1>Todo App</h1>
        <!-- Conditional rendering : v-if...v..else-if -->
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>


Now vue starts using lot of composable apis, which is  every growing....
https://vueuse.org/

<script setup>
import useFetch from './composables/useFetch.js'
import { useTitle } from '@vueuse/core'

const url = 'https://jsonplaceholder.typicode.com/todos'
const title = useTitle('New Titlte', { titleTemplate: '%s My Awesome Website' })

const { data, error } = useFetch(url)
</script>
<template>
    <div>Todo App</div>
    <div v-if="error">Opps! Error Encountered</div>
    <div v-else-if="data">
        <div v-for="todo of data">
            <p>{{todo.title}}</p>
        </div>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>
<style>

</style>			
.....................................................................................
				Custom Directives
....................................................................................

Code Resuablity Patterns:
.........................

The application code can be reused in vue in various ways.

1.Composables
  Way to reuse application static logic - script code
2.Components
  Way to reuse user interface
3.Directives
  Way to resue underlying DOM features..

Types of Directives:

1.Built in directives
  Directives provided by vue
    v-on,vbind,v-text,v-if,v-for etc...

2.Custom Directives
    Directives are created by us.


How to implement simple custom directive?

Every directive is object , having low level dom features.

Steps to create directive

1.creative directive object
<script setup>
const vFocus = {
    //define life cycle method
    mounted: (element)=>{
        //we can get dom element here on which you attach, then you do dom manipulation
        element.focus()
    }
}
</script>
2.How to attach directive on html element
<template>
    <div class="container" style="margin-top: 50px;">
        <input v-focus />
    </div>
</template>
...................................................................................
			 DOM Maniuplation using directives
....................................................................................
<script setup>
const vHighlight = {
    mounted: (element) => {
        //dom listener
        element.addEventListener('mousemove', evt => {
            highlight('yellow', 'x-large')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(null, null)
        })

        const highlight = (color, size) => {
            element.style.backgroundColor = color
            element.style.fontSize = size
        }
    }
}
</script>
<template>
    <div class="container" style="margin-top: 50px;">
        <h1 v-highlight>Hightlight Me</h1>
    </div>
</template>
.....................................................................................
			  Component Hooks /Directives Hooks
....................................................................................

Directive hooks:
 Directive hooks are methods which are called in very life cycle of directive.

created(element,binding,vnode,prevNode)

beforeMount =called before the target element is inserted into dom.
mounted()=> called before the parent component is updated.
beforeUpdate()=> called after the parent component and all of its children have updated.
update()=> called after before Update
beforeMount()=>before removing element.
unmounted()=> when component is unmounted.
.....................................................................................
			 Directive parameters,modifiers,args
....................................................................................

Eg:
<input v-bind:value="msg"/>
		     |
                     parameter.



Directives can be created at application object level.


eg:
 createApp(App).directive('focus',(element,binding)=>{})

binding is object which hold all information about directives


How to pass parameter to directive and set that parameter.


 .directive('highlight', (element, binding) => {

        //get input from the template 
        console.log(binding)
        const color = binding.value || 'yellow'
        element.addEventListener('mousemove', evt => {
            highlight(color, 'x-large')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(null, null)
        })

        const highlight = (color, size) => {
            element.style.backgroundColor = color
            element.style.fontSize = size
        }
    })


App.vue
<script setup>
import { ref } from 'vue';

const color = ref('pink')
</script>
<template>
    <input v-focus />
    <h1 v-highlight.value="color">Highlight Me</h1>

    <h1 v-highlight>Highlight Me</h1>
</template>
.....................................................................................
				Modifiers
.....................................................................................
Modifieres are extra information to the directive,based on that we can do actions.

.directive('highlight', (element, binding) => {

        //get input from the template 
        console.log(binding)
        let color = binding.value || 'yellow'

        if (binding.modifiers.bar) {
            color = 'green'
        }

        element.addEventListener('mousemove', evt => {
            highlight(color, 'x-large')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(null, null)
        })

        const highlight = (color, size) => {
            element.style.backgroundColor = color
            element.style.fontSize = size
        }
    })

App.vue
<script setup>
import { ref } from 'vue';
const color = ref('pink')
</script>
<template>
    <h1 v-highlight.value="color">Highlight Me</h1>
    <!-- Directive modifie -->
    <h2 v-highlight:foo.bar="color">Highlight with Modifer</h2>
</template>
.....................................................................................
		                    Plugins
.....................................................................................

What is Plugin?

   Plugins are self contained code that usually add app-top level functionality to Vue.

Most of third party libs are integredted as plugin with vue echo system eg vue-router,State Management libs like vueex,pinia.

Plugins are distributed as npm modules, in order to use plugins, we have to do two things

Through plugins we can distribute global utility apis, objects....

1. install plugin npm module

eg:
 npm install vue-router@4

2.Integrate with application object

 createApp(App).use(myPlugin).use(router).use(pinia)

Syntax:

export default {
   install:(app,options)=>{
     //plugin functinality
  }
}
here app is application object reference
here options are input to the plugin.

We will write simple global api  - called upper case.

Note:
 Plugin apis are started with "$" eg : $uppercase, $lowercase,$titlecase,$trim


Step 1:
src/plugins/upppercasePlugin.js
export default {
    install(app, options) {
        //application object reference inside plugin as firt arg
        app.config.globalProperties.$uppercase = key => {
            return key.toUpperCase()
        }
    }
}

Step 1:
register plugin in application object.
<script setup>
</script>
<template>
    <!-- Use plugin -->
    <h1>{{ $uppercase('hello how are you') }}</h1>
</template>
// import './assets/main.css'
// import './assets/app.css'
import 'bootstrap/dist/css/bootstrap.min.css'
import { createApp } from 'vue'
import StatusBar from './components/StatusBar.vue'
import uppercasePlugin from './plugins/uppercasePlugin'

import App from './App.vue'

// // createApp(App).mount('#app')
// const app = createApp(App)

// //Global Components
// app.component('StatusBar', StatusBar)

// app.mount('#app')

//chainining pattern 
createApp(App)
    .component('StatusBar', StatusBar)
    .provide('company', 'vue organization')
    .directive('focus', (element, binding) => {
        element.focus()
    })
    .directive('highlight', (element, binding) => {

        //get input from the template 
        console.log(binding)
        let color = binding.value || 'yellow'

        if (binding.modifiers.bar) {
            color = 'green'
        }

        element.addEventListener('mousemove', evt => {
            highlight(color, 'x-large')
        })
        element.addEventListener('mouseleave', evt => {
            highlight(null, null)
        })

        const highlight = (color, size) => {
            element.style.backgroundColor = color
            element.style.fontSize = size
        }
    })
    .use(uppercasePlugin)
    .mount('#app')

Step 3: 
Use plugin functionality inside app.

<script setup>
</script>
<template>
    <!-- Use plugin -->
    <h1>{{ $uppercase('hello how are you') }}</h1>
</template>

....................................................................................
			 Statement Management - Pinia
....................................................................................

What is State Management?
  
State represents data of the compoent that may change over period of time when ever the user interacts with UI.

Generally , Every Component instance already "manages" its own reactive state.

eg:

<script setup>
 import {ref} from  'vue'

 const count = ref(0)
 
 function increment(){
    count.value++
 }
 
</script>
<template>
   <h2>{{ count}}
</template>

It is self contained unit with the following parts

1.state, the source of truth that drives our app.
2.view,a declarative mapping of the state
3.actions,the possible ways the state could change in reaction to user inputs from the view

One way  data flow model:

  View------->Actions----->State<------>View.

Different ways of state management:

1.Simple State Management using Reactivity api within component
2.Isloate State of app using Composables" out side component.
3.Isloate State of app using "State Managment Libs" like pinia or vuex.

Vue js and State Management libs:

1.Vuex
   It is old lib which used primarily in vue 2.x, Vuex almost in maintaince mode.

2.Pinia
   It is new lib which primarily in 3.x- It is recommended lib.

What is Pinia?
  Pinia is redsign tool for vue 3 composition api.
  Pinia works both in vue 2 and v3 application.

Core Concepts:
..............

1.Store:
   The store object which encapsulate the components's /app biz logic.

How to create store?
  Pinia provides a factory function called "defineStore"

const store = defineStore('nameofStore',{})

2.state : 
  It is function inside define store which returns reactive state.

3.getters
   Getters as name suggests, it defines computed properties.

4.actions:
    it is similar to methods(listerners) which biz logic -state mutation

   
How to begin with pinia? / How to integreate pina?

 Pinia is just plugin, we have to install and integrate.

npm init vue@latest
Need to install the following packages:
create-vue@3.9.0
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... pinia-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\IBM\2023\Nov\VueJs\pinia-app...

Done. Now run:

  cd pinia-app
  npm install
  npm run dev

cd pinia-app> npm install
.....................................................................................

src/main.js
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)

app.use(createPinia())

app.mount('#app')

Here "createPinia" is factory function which inserts pinia lib as part of app.
...................................................................................

Pinia Coding Style:
1.Options api style pattern
2.Composition api style pattern.

Pinia Store setup using Options api Style:
.........................................

Step 1: 
Declare state
import { defineStore } from "pinia"

export const useCounterStore = defineStore('counter', {
  //state:
  state: () => {
    //return initali reactive State 
    return {
      count: 10
    }
  }
})

How to use the State inside component.
<script setup>
import { useCounterStore } from './stores/counter';
const counterStore = useCounterStore()
</script>
<template>
  <h1>State Management Using Pinia</h1>
  <div>
    <h1>Counter {{ counterStore.count }}</h1>
  </div>
</template>

How to add mutation / biz logic- reactivity?
import { defineStore } from "pinia"

export const useCounterStore = defineStore('counter', {
  //state:
  state: () => {
    //return initali reactive State 
    return {
      count: 10
    }
  },
  //actions: biz logic : state mutation: reactive State 
  actions: {
    //methods 
    increment() {
      return this.count++
    }
  }
})

Template:
<script setup>
import { useCounterStore } from './stores/counter';
const counterStore = useCounterStore()

//listener which updates store 
const onIncrement = () => {
  counterStore.increment()
}
</script>
<template>
  <h1>State Management Using Pinia</h1>
  <div>
    <h1>Counter {{ counterStore.count }}</h1>
    <button @click="onIncrement">+</button>
  </div>
</template>

Computed Properties:Getters
import { defineStore } from "pinia"

export const useCounterStore = defineStore('counter', {
  //state:
  state: () => {
    //return initali reactive State 
    return {
      count: 10
    }
  },
  //actions: biz logic : state mutation: reactive State 
  actions: {
    //methods 
    increment() {
      return this.count++
    }
  },
  //getters: Computed Properties
  getters: {
    value: state => state.count,
    doubleIt: state => state.count * 2
  }
})
<script setup>
import { useCounterStore } from './stores/counter';
const counterStore = useCounterStore()

//listener which updates store 
const onIncrement = () => {
  counterStore.increment()
}
</script>
<template>
  <h1>State Management Using Pinia</h1>
  <div>
    <h1>Counter {{ counterStore.count }}</h1>
    <h2>Getters Counter:{{counterStore.value }} Double:{{counterStore.doubleIt }}</h2>
    <button @click="onIncrement">+</button>
  </div>
</template>
.....................................................................................
			 Compostion API Style
.....................................................................................

src/stores/like.js

import { defineStore } from "pinia";
import { computed, ref } from "vue";

export const useLikeStore = defineStore('like', () => {
    //state declaration
    const like = ref(10)

    //actions 
    function increment() {
        like.value++
    }

    //getters 
    const doubleIt = computed(() => {
        return like.value * 2
    })


    //return object which holds initial State 
    return {
        like, increment, doubleIt
    }

})
App.vue
<script setup>
import { useLikeStore } from './stores/like'
const likeStore = useLikeStore()
</script>
<template>
    <h1>Like {{ likeStore.like }} double It : {{ likeStore.doubleIt }}</h1>
    <button @click="likeStore.increment">+</button>
</template>
....................................................................................
		 API Calls with Pinia Using OPITONS API
....................................................................................
import { defineStore } from "pinia";

export const useTodoStore = defineStore('todos', {
    state: () => {
        return {
            todos: null,
            error: null
        }
    },
    actions: {
        async getTodos(url) {
            try {
                const response = await fetch(url)
                const todos = await response.json()
                this.todos = todos
            }
            catch (err) {
                this.err = err
            }
        }
    },
    getters: {
        todolist: state => state.todos
    }
})

<script setup>
import { onMounted } from 'vue';
import { useTodoStore } from './stores/todosapi'
const todosStore = useTodoStore()
onMounted(() => {
    todosStore.getTodos('https://jsonplaceholder.typicode.com/todos')
})
</script>
<template>
    <div>
        <h1>Todo App using Pinia</h1>
    </div>
    <div v-if="todosStore.error">{{ todosStore.error.message }}</div>
    <div v-else-if="todosStore.todos">
        <ul>
            <li v-for="todo of todosStore.todolist">
                {{ todo.title }}
            </li>
        </ul>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>
...................................................................................
		 API Calls with Pinia Using Composition API
....................................................................................

import { defineStore } from "pinia";
import { ref, computed } from "vue";

//compostion api and pinia
export const useTodoStore = defineStore('todos', () => {
    //state 
    const todos = ref(null)
    const error = ref(null)
    //actions
    async function getTodos(url) {
        try {
            const response = await fetch(url)
            const todos = await response.json()
            this.todos = todos
        }
        catch (err) {
            this.err = error
        }
    }
    const todolist = computed(() => {
        return todos.value
    })
    return {
        getTodos, todolist, error, todos
    }

})

App.vue
<script setup>
import { onMounted } from 'vue';
import { useTodoStore } from './stores/todosapi'
const todosStore = useTodoStore()
onMounted(() => {
    todosStore.getTodos('https://jsonplaceholder.typicode.com/todos')
})
</script>
<template>
    <div>
        <h1>Todo App using Pinia</h1>
    </div>
    <div v-if="todosStore.error">{{ todosStore.error.message }}</div>
    <div v-else-if="todosStore.todos">
        <ul>
            <li v-for="todo of todosStore.todolist">
                {{ todo.title }}
            </li>
        </ul>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>
.....................................................................................
			 Routing- How to build single page apps
....................................................................................

SPA is type of web app built for browsers, all navigations are done by javascript and html only.

SPA is called as client side routing.

SPA core features:

1.All Navigation is controlled by browser.
2.From the server we get only data via apis as json format
3.In spa only one physical page called landing page/home page.
4.Name of the landing page would be "index.html"
5.Rest of the application page are called "virtual pages" which are created by js dynamicallly we call "Components"
6.Navigation is controlled by javascript object called "location and history objects"
7.Frameworks for routing is built on the top of these objects only.
8.In order to building routing we need "HTML 5"

Routing can be implemented using plain js , html 5 and ajax, css3 itself , but in large scale we need framework, vue supports official "router" which is supplied as plugin.

How to use router?

npm install vue-router@4 

This is for existing application...

npm init vue@latest

Vue.js - The Progressive JavaScript Framework

√ Project name: ... router-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\IBM\2023\Nov\VueJs\router-app...

Done. Now run:

  cd router-app
  npm install
  npm run dev


E:\session\IBM\2023\Nov\VueJs>cd router-app

E:\session\IBM\2023\Nov\VueJs\router-app>npm install

added 30 packages, and audited 31 packages in 13s

6 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
.....................................................................................
			  Steps for building Vue app with routing
.....................................................................................

your-app
  |
  src
   |
   components
   router
   stores
   views
   composables
   plugins
   directives

views and components are both are same only.

views are  components which are used to render route / page, internally which renders other compoents
eg:
  Like

  LikeView -------------LikeComponent----stores/composables

router:
 which has route configuration.
.....................................................................................

App flow:
  entry point is main.js

App.vue is master page which has master menus and place holders
.....................................................................................

Steps:

1.Route configuration.
 Url pattern and how that url is mapped against "View".

src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/about',
      name: 'about',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/AboutView.vue')
    }
  ]
})

export default router

2.main.js
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'

import App from './App.vue'
import router from './router'

const app = createApp(App)

app.use(createPinia())
app.use(router)

app.mount('#app')

3.Master Page :App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <header>
    <img alt="Vue logo" class="logo" src="@/assets/logo.svg" width="125" height="125" />

    <div class="wrapper">
      <HelloWorld msg="You did it!" />

      <nav>
        <RouterLink to="/">Home</RouterLink>
        <RouterLink to="/about">About</RouterLink>
      </nav>
    </div>
  </header>

  <RouterView />
</template>

<style scoped>
header {
  line-height: 1.5;
  max-height: 100vh;
}

.logo {
  display: block;
  margin: 0 auto 2rem;
}

nav {
  width: 100%;
  font-size: 12px;
  text-align: center;
  margin-top: 2rem;
}

nav a.router-link-exact-active {
  color: var(--color-text);
}

nav a.router-link-exact-active:hover {
  background-color: transparent;
}

nav a {
  display: inline-block;
  padding: 0 1rem;
  border-left: 1px solid var(--color-border);
}

nav a:first-of-type {
  border: 0;
}

@media (min-width: 1024px) {
  header {
    display: flex;
    place-items: center;
    padding-right: calc(var(--section-gap) / 2);
  }

  .logo {
    margin: 0 2rem 0 0;
  }

  header .wrapper {
    display: flex;
    place-items: flex-start;
    flex-wrap: wrap;
  }

  nav {
    text-align: left;
    margin-left: -1rem;
    font-size: 1rem;

    padding: 1rem 0;
    margin-top: 1rem;
  }
}
</style>
.....................................................................................

Built in Router Objects/Compoents

1.router-link
  In order to create hyper links

2.router-view
  It is place holder , will display the compoent/view that corresponds to the URL,

.....................................................................................

Basic Url setup:

import { createRouter, createWebHistory } from "vue-router"
import HomeView from '../views/HomeView.vue'
import AboutView from '../views/AboutView.vue'

//route configuration
const routes = [{
  path: '/',
  name: 'index',
  component: HomeView
},
{
  path: '/home',
  name: 'home',
  component: HomeView
},
{
  path: '/about',
  name: 'about',
  component: AboutView
}
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})
export default router;

App.vue
<script setup>
import { RouterLink } from 'vue-router';
</script>
<template>
  <div>
    <h1>Router app</h1>
    <hr />
    <nav>
      <ul>
        <li>
          <RouterLink to="/home">Home</RouterLink>
        </li>
        <li>
          <RouterLink to="/about">About</RouterLink>
        </li>
      </ul>
    </nav>
    <hr />
    <!-- Place holder which display View -->
    <RouterView />
  </div>
</template>

views/Homeview.vue
<script setup>
</script>

<template>
  <main>
    <h1>Home View</h1>
  </main>
</template>
views/AboutView.vue
<template>
  <div class="about">
    <h1>This is an about page</h1>
  </div>
</template>
....................................................................................
				Lazy loading 
....................................................................................

Loading the component on demand , when ever the menu is clicked.

route/index.js

{
  path: '/review',
  name: 'review',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/ReviewView.vue')
}

App.vue
  <li>
          <RouterLink to="/review">Review</RouterLink>
        </li>
      </ul>

views/Review.vue
<template>
    <div>
        <h1>This is Review Page</h1>
    </div>
</template>
.....................................................................................
			 Routing and compoents

1.Using reactive state and props...


src/components/like.vue
<script setup>
import { ref } from 'vue';

const like = ref(0)
</script>
<template>
    <div>
        <h1>Likes {{ like }}</h1>
        <button @click="like++">Like</button>
    </div>
</template>

src/App.vue
<script setup>
import { RouterLink } from 'vue-router';
</script>
<template>
  <div>
    <h1>Router app</h1>
    <hr />
    <nav>
      <ul>
        <li>
          <RouterLink to="/home">Home</RouterLink>
        </li>
        <li>
          <RouterLink to="/about">About</RouterLink>
        </li>
        <li>
          <RouterLink to="/review">Review</RouterLink>
        </li>

      </ul>
    </nav>
    <hr />
    <!-- Place holder which display View -->
    <RouterView />
  </div>
</template>

src/router/index.js
import { createRouter, createWebHistory } from "vue-router"
import HomeView from '../views/HomeView.vue'
import AboutView from '../views/AboutView.vue'

//route configuration
const routes = [{
  path: '/',
  name: 'index',
  component: HomeView
},
{
  path: '/home',
  name: 'home',
  component: HomeView
},
{
  path: '/about',
  name: 'about',
  component: AboutView
},
{
  path: '/review',
  name: 'review',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/ReviewView.vue')
}
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})
export default router;
.....................................................................................
			  API call using pinia
.....................................................................................

src/stores/photostore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";

//compostion api and pinia
export const usePhotoStore = defineStore('photos', () => {
    //state 
    const photos = ref(null)
    const error = ref(null)
    //actions
    async function getPhotos(url) {
        try {
            const response = await fetch(url)
            const photos = await response.json()
            this.photos = photos
        }
        catch (err) {
            this.err = error
        }
    }
    const photoslist = computed(() => {
        return photos.value
    })
    return {
        getPhotos, photoslist, error, photos
    }

})

src/components/photo.vue
<script setup>
import { onMounted } from 'vue';
import { usePhotoStore } from '../stores/photostore'
const photosStore = usePhotoStore()
onMounted(() => {
    photosStore.getPhotos('https://jsonplaceholder.typicode.com/photos')
})
</script>

<template>
    <div v-if="photosStore.error">{{ photosStore.error.message }}</div>
    <div v-else-if="photosStore.photos">
        <div v-for="photo of photosStore.photoslist">
            <h1>Album ID {{ photo.albumId }}</h1>
            <H3>{{ photo.title }}</H3>
            <img :src="photo.url" height="100" width="100" />
        </div>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>

src/views/photoview.vue
<script setup>
import Photos from '@/components/Photos.vue';

</script>
<template>
    <div>
        <h1 style="text-align: center;">Album Page</h1>
        <Photos />
    </div>
</template>

router.js
{
  path: '/photo',
  name: 'photo',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/PhotoView.vue')
}
....................................................................................
			Dynamic routing: Master Details Page


url patterns

/photos/:id

/phtos/1

............
eg:
Master Page:
............
src/stores/photostore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";

//compostion api and pinia
export const usePhotoStore = defineStore('photos', () => {
    //state 
    const photos = ref(null)
    const error = ref(null)
    //actions
    async function getPhotos(url) {
        try {
            const response = await fetch(url)
            const photos = await response.json()
            this.photos = photos
        }
        catch (err) {
            this.err = error
        }
    }
    const photoslist = computed(() => {
        return photos.value
    })
    return {
        getPhotos, photoslist, error, photos
    }

})

src/components/Photos.vue
<script setup>
import { onMounted } from 'vue';
import { usePhotoStore } from '../stores/photostore'
import { RouterLink } from 'vue-router';

const photosStore = usePhotoStore()
onMounted(() => {
    photosStore.getPhotos('https://jsonplaceholder.typicode.com/photos')
})
</script>

<template>
    <div v-if="photosStore.error">{{ photosStore.error.message }}</div>
    <div v-else-if="photosStore.photos">
        <div v-for="photo of photosStore.photoslist">
            <h1>Album ID {{ photo.albumId }}</h1>
            <RouterLink :to="'/photosdetails/' + photo.id">
                <img :src="photo.url" height="100" width="100" />
            </RouterLink>
            <H3>{{ photo.title }}</H3>

        </div>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>

src/views/PhotosView.vue
<script setup>
import Photos from '@/components/Photos.vue';

</script>
<template>
    <div>
        <h1 style="text-align: center;">Album Page</h1>
        <Photos />
    </div>
</template>
............................................
Details Page
............
src/stores/photosdetails.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";

//compostion api and pinia
export const usePhotoDetail = defineStore('photosDetail', () => {
    //state 
    const photo = ref(null)
    const error = ref(null)
    //actions
    async function getPhoto(url) {
        try {
            const response = await fetch(url)
            const photo = await response.json()
            this.photo = photo
        }
        catch (err) {
            this.err = error
        }
    }
    const singlePhoto = computed(() => {
        return photo.value
    })
    return {
        getPhoto, singlePhoto, error, photo
    }

})

src/components/PhotoDetail.vue
<script setup>
import { onMounted } from 'vue';
import { usePhotoDetail } from '../stores/photodetailstore'
const params = defineProps(['id'])
// make api call to get particular photo.
const photoDetailStore = usePhotoDetail()

onMounted(() => {
    photoDetailStore.getPhoto(`https://jsonplaceholder.typicode.com/photos/${params.id}`)
})
</script>

<template>
    <div style="margin: auto;">
        <div v-if="photoDetailStore.error">{{ photoDetailStore.error.message }}</div>
        <div v-else-if="photoDetailStore.photo">
            <h1>Id {{ photoDetailStore.singlePhoto.id }}</h1>
            <img :src="photoDetailStore.singlePhoto.url" height="500" width="500" />
            <h3>{{ photoDetailStore.singlePhoto.title }}</h3>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>
.
src/views/PhotoDetailsView.vue
<script setup>
import { useRoute } from 'vue-router';
import PhotoDetails from '../components/PhotoDetail.vue'
const route = useRoute()
</script>
<template>
    <PhotoDetails :id="route.params.id" />
</template>

src/router/index.js
import { createRouter, createWebHistory } from "vue-router"
import HomeView from '../views/HomeView.vue'
import AboutView from '../views/AboutView.vue'
//route configuration
const routes = [{
  path: '/',
  name: 'index',
  component: HomeView
},
{
  path: '/home',
  name: 'home',
  component: HomeView
},
{
  path: '/about',
  name: 'about',
  component: AboutView
},
{
  path: '/review',
  name: 'review',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/ReviewView.vue')
},
{
  path: '/photo',
  name: 'photo',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/PhotoView.vue')
},
{
  path: '/photosdetails/:id',
  name: 'photodetails',
  component: () => import('../views/PhotsDetailsView.vue')
}
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})
export default router;
.................................&&&&&&&&&&&&&&&&&&&&&...............................
				Nested Menus -Nested Rotuer-SubMenu
					 &&
				      Redirection
....................................................................................

Building SubMenu

Movie
 |
 Sci
 Drama
 Action
 Commadi

src/router/index.js
import { createRouter, createWebHistory } from "vue-router"
import HomeView from '../views/HomeView.vue'
import AboutView from '../views/AboutView.vue'
//route configuration
const routes = [{
  path: '/',
  name: 'index',
  // component: HomeView
  redirect: { name: 'home' }
},
{
  path: '/home',
  name: 'home',
  component: HomeView
},
{
  path: '/about',
  name: 'about',
  component: AboutView
},
{
  path: '/review',
  name: 'review',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/ReviewView.vue')
},
{
  path: '/photo',
  name: 'photo',
  //route level coding spilting 
  //this generates a separate chunk(reivew.[hash].js)
  //this is lazy loaded when the route is visited
  component: () => import('../views/PhotoView.vue')
},
{
  path: '/photosdetails/:id',
  name: 'photodetails',
  component: () => import('../views/PhotsDetailsView.vue')
},
{
  path: '/movies',
  name: 'movies',
  component: () => import('../views/MoviesView.vue'),
  children: [
    {
      path: '',
      redirect: { name: 'action' }
    },
    {
      path: 'action',
      name: 'action',
      component: () => import('../views/ActionView.vue')
    },
    {
      path: 'dramma',
      name: 'dramma',
      component: () => import('../views/DrammaView.vue')
    }
  ]
}
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
})
export default router;

src/views/MoviesView.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router';
</script>
<template>
    <h1>Movies Page</h1>
    <ul>
        <li>
            <RouterLink to="/movies/action">
                Action
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/dramma">
                Dramma
            </RouterLink>
        </li>
    </ul>
    <RouterView />
</template>

src/views/ActionView.vue
<script setup>
</script>
<template>
    <h1>Action Page</h1>
</template>

src/views/DrammaView.vue
<script setup>
</script>
<template>
    <h1>Dramma Page</h1>
</template>












